#line 1 "NanorexMMPImportExport.rl"
// *********************** GENERATED BY RAGEL 6.0 *******************
// ** Do not edit directly. Edit NanorexMMPImportExport.rl instead **
// ******************************************************************

// Copyright 2008 Nanorex, Inc.  See LICENSE file for details.

#include "NanorexMMPImportExport.h"

#define VERBOSE

#if defined(VERBOSE)
#define CDEBUG(x) DEBUG_MSG(filename, line, x)
inline void DEBUG_MSG(string const& filename, int line, string const& s)
{
    ostringstream msg;
    msg << line << ": " << s;
    NXLOG_INFO(filename, msg.str());
/*    Nanorex::NXLogger* logger = Nanorex::NXLogger::Instance();
    if (logger != 0)
        logger->log(Nanorex::NXLogLevel_Info, filename, msg.str());*/
}
#else
#define CDEBUG(x)
#endif




#line 270 "NanorexMMPImportExport.rl"


#line 274 "NanorexMMPImportExport.rl"

#line 36 "NanorexMMPImportExport.cpp"
static const char _mmp_parser_actions[] = {
	0, 1, 0, 1, 1, 1, 3, 1, 
	4, 1, 5, 1, 6, 1, 7, 1, 
	9, 1, 10, 1, 11, 1, 12, 1, 
	13, 1, 14, 1, 15, 1, 16, 1, 
	17, 1, 18, 1, 25, 1, 27, 1, 
	28, 1, 31, 1, 32, 1, 33, 1, 
	34, 1, 35, 1, 36, 1, 37, 1, 
	38, 1, 39, 1, 40, 1, 41, 2, 
	1, 8, 2, 2, 9, 2, 2, 10, 
	2, 2, 11, 2, 4, 6, 2, 6, 
	29, 2, 12, 18, 2, 13, 18, 2, 
	14, 18, 2, 15, 18, 2, 16, 18, 
	2, 17, 18, 2, 19, 26, 2, 20, 
	26, 2, 21, 26, 2, 22, 26, 2, 
	23, 26, 2, 24, 26, 2, 25, 27, 
	2, 36, 38, 3, 4, 6, 29, 3, 
	6, 29, 30, 4, 4, 6, 29, 30
	
};

static const short _mmp_parser_key_offsets[] = {
	0, 0, 1, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 22, 24, 26, 
	28, 30, 32, 34, 36, 38, 42, 47, 
	49, 51, 53, 55, 57, 59, 63, 68, 
	72, 73, 74, 75, 77, 79, 81, 83, 
	85, 88, 93, 98, 102, 107, 113, 117, 
	120, 124, 131, 133, 139, 143, 150, 152, 
	158, 162, 169, 171, 177, 181, 184, 193, 
	194, 195, 199, 203, 204, 205, 209, 210, 
	211, 215, 216, 217, 221, 222, 223, 227, 
	228, 229, 233, 235, 241, 243, 249, 251, 
	257, 263, 266, 271, 277, 283, 286, 289, 
	292, 295, 298, 301, 305, 315, 326, 337, 
	340, 349, 350, 351, 355, 356, 357, 358, 
	359, 360, 361, 362, 363, 364, 365, 368, 
	378, 389, 400, 410, 421, 433, 444, 457, 
	470, 483, 486, 490, 500, 511, 522, 526, 
	527, 538, 549, 560, 571, 582, 593, 604, 
	608, 619, 623, 629, 633, 645, 658, 662
};

static const char _mmp_parser_trans_keys[] = {
	10, 10, 10, 116, 10, 111, 10, 109, 
	10, 111, 10, 110, 10, 100, 10, 103, 
	10, 114, 10, 111, 10, 117, 10, 112, 
	10, 114, 10, 111, 10, 117, 10, 112, 
	10, 110, 10, 102, 10, 111, 10, 32, 
	9, 13, 10, 32, 97, 9, 13, 10, 
	116, 10, 111, 10, 109, 10, 110, 10, 
	102, 10, 111, 10, 32, 9, 13, 10, 
	32, 97, 9, 13, 32, 97, 9, 13, 
	116, 111, 109, 10, 116, 10, 111, 10, 
	109, 10, 111, 10, 108, 32, 9, 13, 
	32, 9, 13, 48, 57, 32, 9, 13, 
	48, 57, 32, 40, 9, 13, 32, 9, 
	13, 48, 57, 32, 41, 9, 13, 48, 
	57, 32, 41, 9, 13, 32, 9, 13, 
	32, 40, 9, 13, 32, 43, 45, 9, 
	13, 48, 57, 48, 57, 32, 44, 9, 
	13, 48, 57, 32, 44, 9, 13, 32, 
	43, 45, 9, 13, 48, 57, 48, 57, 
	32, 44, 9, 13, 48, 57, 32, 44, 
	9, 13, 32, 43, 45, 9, 13, 48, 
	57, 48, 57, 32, 41, 9, 13, 48, 
	57, 32, 41, 9, 13, 32, 9, 13, 
	32, 99, 100, 105, 108, 116, 118, 9, 
	13, 112, 107, 10, 32, 9, 13, 10, 
	32, 9, 13, 101, 102, 10, 32, 9, 
	13, 110, 118, 10, 32, 9, 13, 105, 
	110, 10, 32, 9, 13, 117, 98, 10, 
	32, 9, 13, 100, 119, 10, 32, 9, 
	13, 48, 57, 32, 41, 9, 13, 48, 
	57, 48, 57, 32, 44, 9, 13, 48, 
	57, 48, 57, 32, 44, 9, 13, 48, 
	57, 49, 50, 51, 97, 99, 103, 32, 
	9, 13, 32, 9, 13, 48, 57, 10, 
	32, 9, 13, 48, 57, 10, 32, 9, 
	13, 48, 57, 32, 9, 13, 32, 9, 
	13, 32, 9, 13, 32, 9, 13, 32, 
	9, 13, 32, 9, 13, 32, 40, 9, 
	13, 32, 95, 9, 13, 48, 57, 65, 
	90, 97, 122, 32, 41, 95, 9, 13, 
	48, 57, 65, 90, 97, 122, 32, 41, 
	95, 9, 13, 48, 57, 65, 90, 97, 
	122, 32, 9, 13, 32, 99, 100, 105, 
	108, 116, 118, 9, 13, 112, 107, 10, 
	32, 9, 13, 101, 102, 110, 118, 105, 
	110, 117, 98, 100, 119, 32, 9, 13, 
	32, 95, 9, 13, 48, 57, 65, 90, 
	97, 122, 32, 61, 95, 9, 13, 48, 
	57, 65, 90, 97, 122, 32, 61, 95, 
	9, 13, 48, 57, 65, 90, 97, 122, 
	32, 95, 9, 13, 48, 57, 65, 90, 
	97, 122, 10, 32, 45, 9, 13, 48, 
	57, 65, 90, 97, 122, 10, 32, 45, 
	95, 9, 13, 48, 57, 65, 90, 97, 
	122, 10, 32, 45, 9, 13, 48, 57, 
	65, 90, 97, 122, 10, 32, 45, 61, 
	95, 9, 13, 48, 57, 65, 90, 97, 
	122, 10, 32, 45, 61, 95, 9, 13, 
	48, 57, 65, 90, 97, 122, 10, 32, 
	45, 61, 95, 9, 13, 48, 57, 65, 
	90, 97, 122, 32, 9, 13, 32, 40, 
	9, 13, 32, 95, 9, 13, 48, 57, 
	65, 90, 97, 122, 32, 41, 95, 9, 
	13, 48, 57, 65, 90, 97, 122, 32, 
	41, 95, 9, 13, 48, 57, 65, 90, 
	97, 122, 10, 32, 9, 13, 10, 10, 
	32, 35, 97, 98, 101, 103, 105, 109, 
	9, 13, 10, 32, 35, 97, 98, 101, 
	103, 105, 109, 9, 13, 10, 32, 35, 
	97, 98, 101, 103, 105, 109, 9, 13, 
	10, 32, 35, 97, 98, 101, 103, 105, 
	109, 9, 13, 10, 32, 35, 97, 98, 
	101, 103, 105, 109, 9, 13, 10, 32, 
	35, 97, 98, 101, 103, 105, 109, 9, 
	13, 10, 32, 35, 97, 98, 101, 103, 
	105, 109, 9, 13, 32, 97, 9, 13, 
	10, 32, 35, 97, 98, 101, 103, 105, 
	109, 9, 13, 10, 32, 9, 13, 10, 
	32, 9, 13, 48, 57, 10, 32, 9, 
	13, 10, 32, 45, 95, 9, 13, 48, 
	57, 65, 90, 97, 122, 10, 32, 45, 
	61, 95, 9, 13, 48, 57, 65, 90, 
	97, 122, 10, 32, 9, 13, 0
};

static const char _mmp_parser_single_lengths[] = {
	0, 1, 1, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 3, 2, 
	2, 2, 2, 2, 2, 2, 3, 2, 
	1, 1, 1, 2, 2, 2, 2, 2, 
	1, 1, 1, 2, 1, 2, 2, 1, 
	2, 3, 0, 2, 2, 3, 0, 2, 
	2, 3, 0, 2, 2, 1, 7, 1, 
	1, 2, 2, 1, 1, 2, 1, 1, 
	2, 1, 1, 2, 1, 1, 2, 1, 
	1, 2, 0, 2, 0, 2, 0, 2, 
	6, 1, 1, 2, 2, 1, 1, 1, 
	1, 1, 1, 2, 2, 3, 3, 1, 
	7, 1, 1, 2, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 2, 
	3, 3, 2, 3, 4, 3, 5, 5, 
	5, 1, 2, 2, 3, 3, 2, 1, 
	9, 9, 9, 9, 9, 9, 9, 2, 
	9, 2, 2, 2, 4, 5, 2, 0
};

static const char _mmp_parser_range_lengths[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	1, 2, 2, 1, 2, 2, 1, 1, 
	1, 2, 1, 2, 1, 2, 1, 2, 
	1, 2, 1, 2, 1, 1, 1, 0, 
	0, 1, 1, 0, 0, 1, 0, 0, 
	1, 0, 0, 1, 0, 0, 1, 0, 
	0, 1, 1, 2, 1, 2, 1, 2, 
	0, 1, 2, 2, 2, 1, 1, 1, 
	1, 1, 1, 1, 4, 4, 4, 1, 
	1, 0, 0, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 1, 1, 4, 4, 4, 1, 0, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 2, 1, 4, 4, 1, 0
};

static const short _mmp_parser_index_offsets[] = {
	0, 0, 2, 4, 7, 10, 13, 16, 
	19, 22, 25, 28, 31, 34, 37, 40, 
	43, 46, 49, 52, 55, 58, 62, 67, 
	70, 73, 76, 79, 82, 85, 89, 94, 
	98, 100, 102, 104, 107, 110, 113, 116, 
	119, 122, 126, 130, 134, 138, 143, 147, 
	150, 154, 160, 162, 167, 171, 177, 179, 
	184, 188, 194, 196, 201, 205, 208, 217, 
	219, 221, 225, 229, 231, 233, 237, 239, 
	241, 245, 247, 249, 253, 255, 257, 261, 
	263, 265, 269, 271, 276, 278, 283, 285, 
	290, 297, 300, 304, 309, 314, 317, 320, 
	323, 326, 329, 332, 336, 343, 351, 359, 
	362, 371, 373, 375, 379, 381, 383, 385, 
	387, 389, 391, 393, 395, 397, 399, 402, 
	409, 417, 425, 432, 440, 449, 457, 467, 
	477, 487, 490, 494, 501, 509, 517, 521, 
	523, 534, 545, 556, 567, 578, 589, 600, 
	604, 615, 619, 624, 628, 637, 647, 651
};

static const unsigned char _mmp_parser_indicies[] = {
	1, 0, 3, 2, 1, 4, 0, 1, 
	5, 0, 1, 6, 0, 1, 7, 0, 
	1, 8, 0, 1, 9, 0, 1, 10, 
	0, 1, 11, 0, 1, 12, 0, 1, 
	13, 0, 1, 14, 0, 1, 15, 0, 
	1, 16, 0, 1, 17, 0, 1, 18, 
	0, 1, 19, 0, 1, 20, 0, 1, 
	21, 0, 23, 22, 22, 0, 23, 22, 
	24, 22, 0, 1, 25, 0, 1, 26, 
	0, 1, 27, 0, 1, 28, 0, 1, 
	29, 0, 1, 30, 0, 32, 31, 31, 
	0, 32, 31, 24, 31, 0, 34, 35, 
	34, 33, 36, 33, 37, 33, 38, 33, 
	1, 39, 0, 1, 40, 0, 1, 41, 
	0, 1, 42, 0, 1, 43, 0, 44, 
	44, 45, 44, 44, 46, 45, 47, 47, 
	46, 45, 48, 49, 48, 45, 49, 49, 
	50, 45, 51, 52, 51, 50, 45, 51, 
	52, 51, 45, 53, 53, 45, 53, 54, 
	53, 45, 54, 55, 56, 54, 57, 45, 
	57, 45, 58, 59, 58, 57, 45, 60, 
	61, 60, 45, 61, 62, 63, 61, 64, 
	45, 64, 45, 65, 66, 65, 64, 45, 
	67, 68, 67, 45, 68, 69, 70, 68, 
	71, 45, 71, 45, 72, 73, 72, 71, 
	45, 74, 75, 74, 45, 76, 76, 45, 
	76, 77, 78, 79, 80, 81, 82, 76, 
	45, 83, 45, 84, 45, 86, 85, 85, 
	45, 88, 87, 87, 45, 89, 45, 90, 
	45, 92, 91, 91, 45, 93, 45, 94, 
	45, 96, 95, 95, 45, 97, 45, 98, 
	45, 100, 99, 99, 45, 101, 45, 102, 
	45, 104, 103, 103, 45, 105, 45, 106, 
	45, 108, 107, 107, 45, 109, 45, 110, 
	111, 110, 109, 45, 112, 45, 113, 114, 
	113, 112, 45, 115, 45, 116, 117, 116, 
	115, 45, 118, 119, 120, 121, 122, 123, 
	45, 124, 124, 45, 125, 125, 126, 45, 
	128, 127, 127, 126, 45, 130, 129, 129, 
	126, 45, 131, 131, 45, 132, 132, 45, 
	133, 133, 45, 134, 134, 45, 135, 135, 
	45, 136, 136, 45, 136, 137, 136, 45, 
	137, 138, 137, 138, 138, 138, 45, 139, 
	140, 139, 139, 139, 139, 139, 45, 139, 
	140, 139, 139, 139, 139, 139, 45, 141, 
	141, 45, 141, 142, 143, 144, 145, 146, 
	147, 141, 45, 148, 45, 149, 45, 150, 
	149, 149, 45, 151, 45, 149, 45, 152, 
	45, 149, 45, 153, 45, 149, 45, 154, 
	45, 149, 45, 155, 45, 149, 45, 156, 
	156, 45, 156, 157, 156, 157, 157, 157, 
	45, 158, 159, 158, 158, 158, 158, 158, 
	45, 158, 159, 158, 158, 158, 158, 158, 
	45, 159, 160, 159, 160, 160, 160, 45, 
	162, 161, 163, 161, 163, 163, 163, 45, 
	162, 161, 163, 157, 161, 164, 164, 164, 
	45, 162, 161, 163, 161, 163, 163, 163, 
	45, 166, 165, 163, 159, 158, 165, 167, 
	167, 167, 45, 166, 165, 163, 159, 169, 
	165, 168, 168, 168, 45, 166, 165, 163, 
	159, 158, 165, 167, 167, 167, 45, 170, 
	170, 45, 170, 171, 170, 45, 171, 172, 
	171, 172, 172, 172, 45, 173, 174, 173, 
	173, 173, 173, 173, 45, 173, 174, 173, 
	173, 173, 173, 173, 45, 175, 174, 174, 
	45, 177, 176, 179, 178, 2, 180, 181, 
	182, 183, 184, 185, 178, 0, 188, 187, 
	189, 190, 191, 192, 193, 194, 195, 187, 
	186, 1, 178, 2, 180, 181, 182, 183, 
	184, 185, 178, 0, 198, 197, 199, 200, 
	201, 202, 203, 204, 205, 197, 196, 1, 
	206, 2, 180, 181, 182, 183, 207, 185, 
	206, 0, 209, 208, 189, 210, 191, 192, 
	193, 194, 195, 208, 186, 23, 211, 2, 
	212, 181, 182, 183, 184, 185, 211, 0, 
	34, 35, 34, 33, 213, 211, 2, 212, 
	181, 182, 183, 184, 185, 211, 0, 88, 
	87, 87, 45, 130, 129, 129, 126, 45, 
	150, 149, 149, 45, 162, 161, 163, 157, 
	161, 164, 164, 164, 45, 166, 165, 163, 
	159, 169, 165, 168, 168, 168, 45, 175, 
	174, 174, 45, 45, 0
};

static const unsigned char _mmp_parser_trans_targs_wi[] = {
	1, 137, 2, 139, 4, 5, 140, 7, 
	8, 140, 10, 11, 12, 13, 140, 15, 
	16, 17, 140, 19, 20, 21, 22, 141, 
	35, 24, 25, 140, 27, 28, 29, 30, 
	143, 0, 31, 32, 33, 34, 136, 36, 
	37, 140, 39, 140, 41, 0, 42, 43, 
	43, 44, 45, 46, 47, 48, 49, 50, 
	86, 51, 52, 53, 52, 53, 54, 84, 
	55, 56, 57, 56, 57, 58, 82, 59, 
	60, 61, 60, 61, 62, 63, 67, 70, 
	73, 76, 79, 64, 65, 66, 145, 66, 
	145, 68, 69, 66, 145, 71, 72, 66, 
	145, 74, 75, 66, 145, 77, 78, 66, 
	145, 80, 81, 66, 145, 83, 60, 61, 
	85, 56, 57, 87, 52, 53, 89, 93, 
	94, 95, 96, 97, 90, 90, 91, 92, 
	146, 92, 146, 90, 90, 90, 90, 90, 
	99, 100, 101, 102, 103, 104, 105, 108, 
	110, 112, 114, 116, 106, 107, 147, 109, 
	111, 113, 115, 117, 119, 120, 121, 122, 
	123, 124, 148, 125, 126, 127, 149, 128, 
	126, 120, 130, 131, 132, 133, 134, 150, 
	135, 151, 138, 136, 3, 6, 9, 14, 
	26, 38, 1, 138, 136, 2, 3, 6, 
	9, 14, 26, 38, 1, 138, 136, 2, 
	3, 6, 9, 14, 26, 38, 140, 18, 
	142, 144, 23, 142, 23, 144
};

static const unsigned char _mmp_parser_trans_actions_wi[] = {
	0, 0, 0, 0, 0, 0, 51, 0, 
	0, 53, 0, 0, 0, 0, 47, 0, 
	0, 0, 45, 0, 0, 0, 0, 0, 
	0, 0, 0, 120, 0, 0, 0, 0, 
	0, 61, 0, 0, 0, 0, 55, 0, 
	0, 55, 0, 49, 0, 0, 3, 13, 
	0, 0, 63, 0, 0, 0, 0, 0, 
	0, 3, 15, 15, 0, 0, 0, 0, 
	3, 17, 17, 0, 0, 0, 0, 3, 
	19, 19, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 29, 93, 0, 
	33, 0, 0, 21, 81, 0, 0, 23, 
	84, 0, 0, 27, 90, 0, 0, 31, 
	96, 0, 0, 25, 87, 3, 72, 72, 
	3, 69, 69, 3, 66, 66, 0, 0, 
	0, 0, 0, 0, 99, 0, 3, 35, 
	117, 0, 37, 102, 105, 108, 114, 111, 
	0, 0, 0, 7, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 39, 0, 
	0, 0, 0, 0, 0, 0, 7, 0, 
	0, 78, 127, 11, 11, 123, 131, 75, 
	75, 7, 0, 0, 0, 7, 0, 41, 
	0, 43, 0, 0, 0, 0, 0, 0, 
	0, 0, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 57, 57, 57, 57, 
	57, 57, 57, 57, 57, 57, 0, 0, 
	59, 59, 59, 0, 0, 0
};

static const unsigned char _mmp_parser_to_state_actions[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 1, 0, 0, 0, 
	0, 1, 1, 0, 0, 1, 1, 0, 
	0, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 0, 1, 0, 1, 0, 
	0, 0, 1, 0, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 5, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	5, 0, 0, 9, 0, 0, 5, 0, 
	0, 0, 0, 0, 5, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 0, 0, 0, 0, 0
};

static const unsigned char _mmp_parser_eof_actions[] = {
	0, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 59, 0, 57, 0, 59, 0, 59, 
	0, 0, 0, 0, 0, 0, 0, 0
};

static const int mmp_parser_start = 136;
static const int mmp_parser_first_final = 136;
static const int mmp_parser_error = 0;

static const int mmp_parser_en_atom_record = 40;
static const int mmp_parser_en_bond_record = 88;
static const int mmp_parser_en_mol_record = 98;
static const int mmp_parser_en_info_atom_record = 118;
static const int mmp_parser_en_group_record = 129;
static const int mmp_parser_en_egroup_record = 135;
static const int mmp_parser_en_main = 136;

#line 275 "NanorexMMPImportExport.rl"


// static data

char const NanorexMMPImportExport::_s_bondOrderString[NUM_BOND_TYPES] = {
 '1', '2', '3', 'a', 'g', 'c'
};

char const
NanorexMMPImportExport::_s_bondOrderNameString[NUM_BOND_TYPES][16] =
{
    "single", "double", "triple", "aromatic", "graphitic", "carbomeric"
};

char const NanorexMMPImportExport::_s_hybridizationName[8][8] = {
    "none", "sp", "sp2", "sp3", "X-hyb4", "X-hyb5", "X-hyb6", "X-hyb7"
};


/* CONSTRUCTOR */
NanorexMMPImportExport::NanorexMMPImportExport()
{
    reset();
}

/* DESTRUCTOR */
NanorexMMPImportExport::~NanorexMMPImportExport()
{
}


/* FUNCTION: reset */
void NanorexMMPImportExport::reset(void)
{
    line = 0;
    atomPtr = NULL;
    bondPtr = NULL;
    foundAtomList.clear();
    targetAtomList.clear();
    molPtr = NULL;
    molSetPtr = NULL;
    while(!molSetPtrStack.empty()) molSetPtrStack.pop();
    
    // initialize the ragel engine
    
#line 479 "NanorexMMPImportExport.cpp"
	{
	cs = mmp_parser_start;
	top = 0;
	}
#line 320 "NanorexMMPImportExport.rl"
}


/* FUNCTION: importFromFile */
NXCommandResult*
NanorexMMPImportExport::
importFromFile(NXMoleculeSet *rootMoleculeSetPtr,
               NXDataStoreInfo *dataStoreInfo,
               const std::string& theFilename,
               int /*frameSetId*/, int /*frameIndex*/)
{
    bool success = true;
    NXCommandResult *result = new NXCommandResult();
    result->setResult(NX_CMD_SUCCESS);
    
    ifstream mmpfile(theFilename.c_str(), ios::in);
    if(!mmpfile) {
        populateCommandResult(result,
                              (string("Couldn't open file: ") + theFilename)
                              .c_str());
        success = false;
    }
    else {
        filename = theFilename;
        success = readMMP(mmpfile, rootMoleculeSetPtr);
    }
    
	// Set the meta information about the data store.
	if (success) {
		dataStoreInfo->setIsSingleStructure(true);
	}
    
    return result;
}


/* FUNCTION: readMMP */
bool NanorexMMPImportExport::readMMP(istream& instream,
                                     NXMoleculeSet *rootMoleculeSetPtr)
{
    reset();
    
    p = RagelIstreamPtr(instream);
    pe = RagelIstreamPtr(instream, 0, ios::end);
    eof = pe;
    
    molSetPtr = rootMoleculeSetPtr;
    molSetPtrStack.push(molSetPtr);
    
    /// @todo handle first 'group' statement and molSetPtrStack initialization
    
    // Ragel parser implementation
    bool success = true;
    
#line 539 "NanorexMMPImportExport.cpp"
	{
	int _klen;
	unsigned int _trans;
	const char *_acts;
	unsigned int _nacts;
	const char *_keys;

	if ( p == pe )
		goto _test_eof;
	if ( cs == 0 )
		goto _out;
_resume:
	_keys = _mmp_parser_trans_keys + _mmp_parser_key_offsets[cs];
	_trans = _mmp_parser_index_offsets[cs];

	_klen = _mmp_parser_single_lengths[cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + _klen - 1;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + ((_upper-_lower) >> 1);
			if ( (*p) < *_mid )
				_upper = _mid - 1;
			else if ( (*p) > *_mid )
				_lower = _mid + 1;
			else {
				_trans += (_mid - _keys);
				goto _match;
			}
		}
		_keys += _klen;
		_trans += _klen;
	}

	_klen = _mmp_parser_range_lengths[cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + (_klen<<1) - 2;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
			if ( (*p) < _mid[0] )
				_upper = _mid - 2;
			else if ( (*p) > _mid[1] )
				_lower = _mid + 2;
			else {
				_trans += ((_mid - _keys)>>1);
				goto _match;
			}
		}
		_trans += _klen;
	}

_match:
	_trans = _mmp_parser_indicies[_trans];
	cs = _mmp_parser_trans_targs_wi[_trans];

	if ( _mmp_parser_trans_actions_wi[_trans] == 0 )
		goto _again;

	_acts = _mmp_parser_actions + _mmp_parser_trans_actions_wi[_trans];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 )
	{
		switch ( *_acts++ )
		{
	case 1:
#line 39 "NanorexMMPImportExport.rl"
	{intval = intval*10 + ((*p)-'0');}
	break;
	case 2:
#line 42 "NanorexMMPImportExport.rl"
	{intval=-intval;}
	break;
	case 4:
#line 51 "NanorexMMPImportExport.rl"
	{stringval = stringval + (*p); }
	break;
	case 6:
#line 56 "NanorexMMPImportExport.rl"
	{stringval2 = stringval2 + (*p); }
	break;
	case 7:
#line 61 "NanorexMMPImportExport.rl"
	{atomID = intval;}
	break;
	case 8:
#line 62 "NanorexMMPImportExport.rl"
	{atomicNum = intval;}
	break;
	case 9:
#line 65 "NanorexMMPImportExport.rl"
	{ x=intval;}
	break;
	case 10:
#line 66 "NanorexMMPImportExport.rl"
	{ y=intval;}
	break;
	case 11:
#line 67 "NanorexMMPImportExport.rl"
	{ z=intval;}
	break;
	case 12:
#line 70 "NanorexMMPImportExport.rl"
	{atomStyleID = NXAtomData::DEF;}
	break;
	case 13:
#line 71 "NanorexMMPImportExport.rl"
	{atomStyleID = NXAtomData::INV;}
	break;
	case 14:
#line 72 "NanorexMMPImportExport.rl"
	{atomStyleID = NXAtomData::VDW;}
	break;
	case 15:
#line 73 "NanorexMMPImportExport.rl"
	{atomStyleID = NXAtomData::LIN;}
	break;
	case 16:
#line 74 "NanorexMMPImportExport.rl"
	{atomStyleID = NXAtomData::CPK;}
	break;
	case 17:
#line 75 "NanorexMMPImportExport.rl"
	{atomStyleID = NXAtomData::TUB;}
	break;
	case 18:
#line 87 "NanorexMMPImportExport.rl"
	{
            ++line;
            if(molPtr != NULL) {
                map<int,OBAtom*>::iterator atomExistsQuery = 
                    foundAtomList.find(atomID);
                // guard against duplicates
                // also a hack to protect against Ragel's duplicate
                // parsing when encountering a blank line
                if(atomExistsQuery == foundAtomList.end()) {
                    // atom was not previously encountered, include
                    ostringstream msg;
                    msg << etab.GetSymbol(atomicNum)
                        << " atom with index " << atomID;
                    CDEBUG(msg.str().c_str());
                    atomPtr = molPtr->NewAtom();
                    NXAtomData *atomIDData = new NXAtomData;
                    atomIDData->SetIdx(atomID);
                    atomIDData->SetRenderStyle(atomStyleID);
                    atomPtr->SetData(atomIDData);
                    atomPtr->SetAtomicNum(atomicNum);
                    atomPtr->SetVector(x,y,z);
                    foundAtomList[atomID] = atomPtr;
                }
            }
            {cs = stack[--top]; goto _again;}
        }
	break;
	case 19:
#line 118 "NanorexMMPImportExport.rl"
	{bond_order=1;}
	break;
	case 20:
#line 119 "NanorexMMPImportExport.rl"
	{bond_order=2;}
	break;
	case 21:
#line 120 "NanorexMMPImportExport.rl"
	{bond_order=3;}
	break;
	case 22:
#line 121 "NanorexMMPImportExport.rl"
	{bond_order=4;}
	break;
	case 23:
#line 122 "NanorexMMPImportExport.rl"
	{bond_order=5;}
	break;
	case 24:
#line 123 "NanorexMMPImportExport.rl"
	{bond_order=6;}
	break;
	case 25:
#line 126 "NanorexMMPImportExport.rl"
	{
            int const& targetAtomIdx = intval;
            map<int,OBAtom*>::iterator targetAtomExistsQuery =
                foundAtomList.find(targetAtomIdx);
            if(targetAtomExistsQuery == foundAtomList.end()) {
                ostringstream errMsg;
                errMsg << "**ERROR** attempting to bond to non-existent atomID "
                       << targetAtomIdx;
                CDEBUG(errMsg.str());
            }
            else {
                OBAtom *targetAtomPtr = foundAtomList[targetAtomIdx];
                // guard against duplicates
                // also a hack to protect against Ragel's duplicate parsing
                // when encountering a blank line
                if(molPtr->GetBond(atomPtr, targetAtomPtr) == NULL) {
                    // bond was not previously encountered, include
                    ostringstream msg;
                    msg << "bonding atom #" << atomPtr->GetIdx() << " to atom #"
                        << targetAtomPtr->GetIdx();
                    CDEBUG(msg.str());
                    targetAtomList.push_back(targetAtomPtr);
                }
                else {
                    ostringstream msg;
                    msg << "bond to atom #" << targetAtomIdx
                        << " already exists";
                    CDEBUG(msg.str());
                }
            }
        }
	break;
	case 26:
#line 161 "NanorexMMPImportExport.rl"
	{ CDEBUG("clearing targetAtomList"); targetAtomList.clear(); }
	break;
	case 27:
#line 165 "NanorexMMPImportExport.rl"
	{
            ++line;
            {
                ostringstream msg;
                msg << _s_bondOrderNameString[bond_order-1] << " bond to "
                    << targetAtomList.size() << " atoms";
                CDEBUG(msg.str());
            }
            if(molPtr != NULL && atomPtr != NULL) {
                vector<OBAtom*>::iterator targetAtomIter;
                for(targetAtomIter  = targetAtomList.begin();
                    targetAtomIter != targetAtomList.end();
                    ++targetAtomIter)
                {
                    bondPtr = molPtr->NewBond();
                    bondPtr->SetBondOrder(bond_order);
                    OBAtom *targetAtomPtr = *targetAtomIter;
                    bondPtr->SetBegin(atomPtr);
                    bondPtr->SetEnd(targetAtomPtr);
                    atomPtr->AddBond(bondPtr);
                    targetAtomPtr->AddBond(bondPtr);
                }
            }
            {cs = stack[--top]; goto _again;}
        }
	break;
	case 28:
#line 201 "NanorexMMPImportExport.rl"
	{
            ++line;
            createNewMolecule();
            molPtr->SetTitle(stringval.c_str());
            {
                ostringstream msg;
                msg << "molecule " << molPtr->GetTitle();
                CDEBUG(msg.str());
            }
            {cs = stack[--top]; goto _again;}
        }
	break;
	case 29:
#line 217 "NanorexMMPImportExport.rl"
	{  {
                          ostringstream msg;
                          msg << "atom-property: " << stringval
                              << " = " << stringval2;
                          CDEBUG(msg.str());
                      }
                          applyAtomType(stringval, stringval2);
                      }
	break;
	case 30:
#line 227 "NanorexMMPImportExport.rl"
	{
            ++line;
            {cs = stack[--top]; goto _again;}
        }
	break;
	case 31:
#line 234 "NanorexMMPImportExport.rl"
	{
            ++line;
            createNewMoleculeSet();
            {
                ostringstream msg;
                msg << "group " << stringval;
                CDEBUG(msg.str());
            }
            {cs = stack[--top]; goto _again;}
        }
	break;
	case 32:
#line 248 "NanorexMMPImportExport.rl"
	{
            ++line;
            closeMoleculeSet();
            CDEBUG("egroup");
        }
	break;
	case 33:
#line 257 "NanorexMMPImportExport.rl"
	{{stack[top++] = cs; cs = 129; goto _again;}}
	break;
	case 34:
#line 258 "NanorexMMPImportExport.rl"
	{{stack[top++] = cs; cs = 135; goto _again;}}
	break;
	case 35:
#line 259 "NanorexMMPImportExport.rl"
	{{stack[top++] = cs; cs = 98; goto _again;}}
	break;
	case 36:
#line 260 "NanorexMMPImportExport.rl"
	{{stack[top++] = cs; cs = 40; goto _again;}}
	break;
	case 37:
#line 261 "NanorexMMPImportExport.rl"
	{{stack[top++] = cs; cs = 88; goto _again;}}
	break;
	case 38:
#line 262 "NanorexMMPImportExport.rl"
	{++line;{stack[top++] = cs; cs = 118; goto _again;}}
	break;
	case 39:
#line 263 "NanorexMMPImportExport.rl"
	{++line; CDEBUG("comment"); }
	break;
	case 40:
#line 264 "NanorexMMPImportExport.rl"
	{++line; CDEBUG("ignored"); }
	break;
	case 41:
#line 267 "NanorexMMPImportExport.rl"
	{success = false;}
	break;
#line 881 "NanorexMMPImportExport.cpp"
		}
	}

_again:
	_acts = _mmp_parser_actions + _mmp_parser_to_state_actions[cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 0:
#line 38 "NanorexMMPImportExport.rl"
	{intval=0;}
	break;
	case 3:
#line 50 "NanorexMMPImportExport.rl"
	{stringval.clear(); stringval = stringval + (*p);}
	break;
	case 5:
#line 55 "NanorexMMPImportExport.rl"
	{stringval2.clear();  stringval2 = stringval2 + (*p);}
	break;
#line 902 "NanorexMMPImportExport.cpp"
		}
	}

	if ( cs == 0 )
		goto _out;
	if ( ++p != pe )
		goto _resume;
	_test_eof: {}
	if ( p == eof )
	{
	const char *__acts = _mmp_parser_actions + _mmp_parser_eof_actions[cs];
	unsigned int __nacts = (unsigned int) *__acts++;
	while ( __nacts-- > 0 ) {
		switch ( *__acts++ ) {
	case 39:
#line 263 "NanorexMMPImportExport.rl"
	{++line; CDEBUG("comment"); }
	break;
	case 40:
#line 264 "NanorexMMPImportExport.rl"
	{++line; CDEBUG("ignored"); }
	break;
	case 41:
#line 267 "NanorexMMPImportExport.rl"
	{success = false;}
	break;
#line 929 "NanorexMMPImportExport.cpp"
		}
	}
	}

	_out: {}
	}
#line 374 "NanorexMMPImportExport.rl"
    
    // End-of-parsing sanity checks
    if(molSetPtrStack.size() != 1) {
        NXLOG_WARNING("NanorexMMPImportExport",
                      "At least one group has no matching egroup statement");
    }
    return success;
}


/* FUNCTION: createNewMoleculeSet */
void NanorexMMPImportExport::createNewMoleculeSet(void)
{
    if(molSetPtr != NULL) {
        NXMoleculeSet *newMolSetPtr = new NXMoleculeSet;
        molSetPtr->addChild(newMolSetPtr);
        molSetPtrStack.push(newMolSetPtr);
        molSetPtr = newMolSetPtr;
    }
}


/* FUNCTION: closeMoleculeSet */
void NanorexMMPImportExport::closeMoleculeSet(void)
{
    molSetPtrStack.pop();
    molSetPtr = (molSetPtrStack.size() == 0) ? NULL : molSetPtrStack.top();
}


/* FUNCTION: createNewMolecule */
inline void NanorexMMPImportExport::createNewMolecule(void)
{ 
    atomPtr = NULL;
    bondPtr = NULL;
    molPtr = NULL;
    molPtr = molSetPtr->newMolecule();
}


/* FUNCTION: applyAtomType */
void NanorexMMPImportExport::applyAtomType(string const& keyStr,
                                           string const& valueStr)
{
    if(molPtr != NULL && atomPtr != NULL) {
        if(keyStr == "atomtype") { // hybridization info
            if(valueStr == "sp") atomPtr->SetHyb(1);
            else if(valueStr == "sp2") atomPtr->SetHyb(2);
            else if(valueStr == "sp2_g") atomPtr->SetHyb(2);
            else if(valueStr == "sp3") atomPtr->SetHyb(3);
            else if(valueStr == "sp3d") atomPtr->SetHyb(3);
            // else ignore
        }
    }
}




/* FUNCTION: exportToFile */
NXCommandResult*
NanorexMMPImportExport::
exportToFile(NXMoleculeSet *molSetPtr,
             NXDataStoreInfo */*dataStoreInfo*/,
             const std::string& theFilename,
             int /*frameSetId*/, int /*frameIndex*/)
{
    NXCommandResult *result = new NXCommandResult();
    result->setResult(NX_CMD_SUCCESS);
    
    ofstream mmpfile(theFilename.c_str(), ios::out);
    if(!mmpfile) {
        populateCommandResult(result,
                              (string("Couldn't open file: ") + theFilename)
                              .c_str());
    }
    else {
        PrintMoleculeSet(mmpfile, molSetPtr);
        mmpfile.close();
    }
    return result;
}


/* FUNCTION: GetAtomID */
/* static */
int NanorexMMPImportExport::GetAtomID(OBAtom *atomPtr)
{
    NXAtomData *atomIDData = 
        static_cast<NXAtomData*>(atomPtr->GetData(NXAtomDataType));
    int atomID = atomIDData->GetIdx();
    return atomID;
}


/* FUNCTION: GetAtomRenderStyleName */
/* static */
char const *const NanorexMMPImportExport::GetAtomRenderStyleName(OBAtom *atomPtr)
{
    NXAtomData *atomDataPtr =
        static_cast<NXAtomData*>(atomPtr->GetData(NXAtomDataType));
    NXAtomData::RenderStyleID atomStyleID = atomDataPtr->GetRenderStyle();
    char const *const atomRenderStyle =
        NXAtomData::GetRenderStyleName(atomStyleID);
    return atomRenderStyle;
}


/* FUNCTION: PrintMolecule */
/* static */
void NanorexMMPImportExport::PrintMolecule(ostream& o,
                                           OBMol *const molPtr)
{
    set<int> prevAtomIdx;
    set<int> prevBondIdx; /// @todo - replace with simple bond count
    
    o << "mol (" << molPtr->GetTitle() << ')' << endl;
    
    OBAtomIterator atomIter;
    OBAtom *atomPtr = NULL;
    // For each atom ...
    for(atomPtr = molPtr->BeginAtom(atomIter);
        atomPtr != NULL;
        atomPtr = molPtr->NextAtom(atomIter))
    {
        // ... write the 'atom' line ...
        int atomID = GetAtomID(atomPtr);
        o << "atom " << atomID << " (" << atomPtr->GetAtomicNum() << ") " << '('
          << atomPtr->x() << ',' << atomPtr->y() << ',' << atomPtr->z()
          << ") " << GetAtomRenderStyleName(atomPtr) << endl;
        
        if(atomPtr->GetHyb() != 0) {
            o << "info atom atomtype = "
              << _s_hybridizationName[atomPtr->GetHyb()] << endl;
        }
        
        // ... write the 'bond' lines for this atom ...
        // ... first sort bonds by type ...
        OBBondIterator bondIter;
        OBBond *bondPtr = NULL;
        vector<int> bondCategories[6];
        for(bondPtr = atomPtr->BeginBond(bondIter);
            bondPtr != NULL;
            bondPtr = atomPtr->NextBond(bondIter))
        {
            // write bond statement only if target atom was previously written
            OBAtom *nbrAtomPtr = bondPtr->GetNbrAtom(atomPtr);
            int nbrAtomID = GetAtomID(nbrAtomPtr);
            if(prevAtomIdx.find(nbrAtomID) != prevAtomIdx.end()) {
                int bondOrder = bondPtr->GetBondOrder();
                bondCategories[bondOrder-1].push_back(nbrAtomID);
                // record bond for sanity check at end
                prevBondIdx.insert(bondPtr->GetIdx());
            }
        }
        
        // ... write the bonds, one line per type ...
        for(int i=0; i<6; ++i) {
            int J = bondCategories[i].size();
            if(J > 0) {
                o << "bond" << _s_bondOrderString[i];
                for(int j=0; j<J; ++j)
                    o << ' ' << bondCategories[i][j];
                o  << endl;
            }
        }
        
        // record atom as 'previously written'
        prevAtomIdx.insert(atomID);
    }
    
    // debug diagnostics
    ostringstream debugMsg;
    debugMsg << "# atoms check ";
    if(molPtr->NumAtoms() == prevAtomIdx.size())
        debugMsg << "PASS ("  << molPtr->NumAtoms() << ')' << endl;
    else
        debugMsg << "FAIL: "
                 << molPtr->NumAtoms() << " != " << prevAtomIdx.size()<< endl;
    
    debugMsg << "# bonds check ";
    if(molPtr->NumBonds() == prevBondIdx.size())
        debugMsg << "PASS (" << molPtr->NumBonds() << ')' << endl;
    else
        debugMsg << "FAIL: "
                 << molPtr->NumBonds() << " != " << prevBondIdx.size()<< endl;
    
    debugMsg.flush();
    NXLOG_DEBUG("NanorexMMPImportExport::PrintMoleculeSet",
                debugMsg.str().c_str());
}


/* FUNCTION: PrintMoleculeSet */
/* static */
void NanorexMMPImportExport::PrintMoleculeSet(ostream& o,
                                              NXMoleculeSet *const molSetPtr)
{
    // Iterate over all child molecules
    OBMolIterator molIter;
    for(molIter = molSetPtr->moleculesBegin();
        molIter != molSetPtr->moleculesEnd();
        ++molIter)
    {
        PrintMolecule(o, *molIter);
    }
    
    // Iterate over all child molecule sets
    NXMoleculeSetIterator molSetIter;
    for(molSetIter = molSetPtr->childrenBegin();
        molSetIter != molSetPtr->childrenEnd();
        ++molSetIter)
    {
        PrintMoleculeSet(o, *molSetIter);
    }
}


/* FUNCTION: populateCommandResult */
void
NanorexMMPImportExport::populateCommandResult (NXCommandResult* result,
                                               const string& message)
{
    result->setResult(NX_PLUGIN_REPORTS_ERROR);
    vector<QString> resultVector;
    resultVector.push_back("OpenBabelImportExport");
    resultVector.push_back(message.c_str());
    result->setParamVector(resultVector);
}

Q_EXPORT_PLUGIN2 (NanorexMMPImportExport, NanorexMMPImportExport)

