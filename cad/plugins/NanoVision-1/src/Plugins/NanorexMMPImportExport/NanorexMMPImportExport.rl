// *********************** GENERATED BY RAGEL 6.0 *******************
// ** Do not edit directly. Edit NanorexMMPImportExport.rl instead **
// ******************************************************************

// Copyright 2008 Nanorex, Inc.  See LICENSE file for details.

#include "NanorexMMPImportExport.h"
#include <QFileInfo>

#define VERBOSE

#if defined(VERBOSE)
#define CDEBUG(x) DEBUG_MSG(filename, line, x)
inline void DEBUG_MSG(string const& filename, int line, string const& s)
{
	ostringstream msg;
	msg << line << ": " << s;
	NXLOG_INFO(filename, msg.str());
/*    Nanorex::NXLogger* logger = Nanorex::NXLogger::Instance();
    if (logger != 0)
        logger->log(Nanorex::NXLogLevel_Info, filename, msg.str());*/
}
#else
#define CDEBUG(x)
#endif




%%{
# Ragel fsm
	
	machine mmp_parser;
	
# ----- utility patterns -----
	include utilities "utilities.rl";
	
# ----- header -----
	# e.g.:     mmpformat 050920 required [; 050930 preferred]
	mmpformat_stmt = space*
		'mmpformat'  space+
		digit{6} space+
		'required' space* 
		(   ';' space+
		    digit{6} space+
		    'preferred'
		)?
		EOL+
		;
	
	kelvin_line = space*  real_number  EOL+;
	
# ----- atom -----
	
	include atom "atom.rl";
	
# ----- molecule -----
	
	include molecule "molecule.rl";
	
# ----- group -----
	
	include group "group.rl";
	
#	group_mol_struct_stmt_body = 
#		(   info_opengroup_line   |
#		    mol_stmt              |
#		    group_mol_struct_stmt
#		)*
#		;
	
#	group_mol_struct_stmt :=
#		group_mol_struct_stmt_begin_line
#		(   info_opengroup_line   |
#		    mol_stmt              |
#		    group_mol_struct_stmt
#		)*
#		group_mol_struct_stmt_end_line
#		;
	
	action infoOpenGroupAction {
		infoOpenGroup
	}
	
	action newMoleculeAction {
		/// @todo
	}
	
	action newGroupAction {
		newGroup(stringval, stringval2);
		fcall group_mol_struct_stmt_scanner;
	}
	
	action endGroupAction {
		endGroup(stringval);
		fret;
	}
	
	group_mol_struct_stmt_scanner := |*
		info_opengroup_line => infoOpenGroupAction;
		mol_decl_line => newMoleculeAction;
		atom_decl_line => newAtomAction;
		bond_line => newBondAction;
		bond_direction_line => newBondDirectionAction;
		egroup_line => endGroupAction;
		group_decl_line => newGroupAction;
		# skip blank and comment lines by providing no actions
		EOL;
	*|;
	
# ----- main parser machine -----
	
end_line = space* 'end' any* EOL+;
	
	
main := mmpformat_stmt
		kelvin_line?
		(group_view_data_stmt  $ 5)?
		( group_mol_struct_stmt_begin_line %{ fcall group_mol_struct_stmt_scanner; } )
		( end1_line    group_clipboard_stmt)?
		end_line
		IGNORED_LINE*
		;
	
# dynamic stack re-sizing
prepush {
	if((int)stack.size() == stackSize) {
		stackSize += stackSize;
	    stack.resize(stackSize, 0);
		// cerr << "Resized stack" << endl;
	}
}
	
}%%

%% # Ragel FSM data

%% write data;


// static data

char const NanorexMMPImportExport::_s_bondOrderString[NUM_BOND_TYPES] = {
	'1', '2', '3', 'a', 'g', 'c'
};

char const
NanorexMMPImportExport::_s_bondOrderNameString[NUM_BOND_TYPES][16] =
{
	"single", "double", "triple", "aromatic", "graphitic", "carbomeric"
};

char const NanorexMMPImportExport::_s_hybridizationName[8][8] = {
	"none", "sp", "sp2", "sp3", "X-hyb4", "X-hyb5", "X-hyb6", "X-hyb7"
};


/* CONSTRUCTOR */
NanorexMMPImportExport::NanorexMMPImportExport()
{
	reset();
}

/* DESTRUCTOR */
NanorexMMPImportExport::~NanorexMMPImportExport()
{
}


/* FUNCTION: reset */
void NanorexMMPImportExport::reset(void)
{
	line = 0;
	atomPtr = NULL;
	bondPtr = NULL;
	foundAtomList.clear();
	targetAtomList.clear();
	molPtr = NULL;
	molSetPtr = NULL;
	while(!molSetPtrStack.empty()) molSetPtrStack.pop();
	stackSize = 2;
	stack.resize(stackSize, 0);
	
    // initialize the ragel engine
	%% write init;
}


/* FUNCTION: importFromFile */
NXCommandResult*
NanorexMMPImportExport::
importFromFile(NXMoleculeSet *rootMoleculeSetPtr,
               NXDataStoreInfo *dataStoreInfo,
               const std::string& theFilename,
               int /*frameSetId*/, int /*frameIndex*/)
{
	bool success = true;
	NXCommandResult *result = new NXCommandResult();
	result->setResult(NX_CMD_SUCCESS);
	
	ifstream mmpfile(theFilename.c_str(), ios::in);
	if(!mmpfile) {
		populateCommandResult(result,
		                      (string("Couldn't open file: ") + theFilename)
		                      .c_str());
		success = false;
	}
	else {
		filename = theFilename;
		success = readMMP(mmpfile, rootMoleculeSetPtr);
	}
	
	// Set the meta information about the data store.
	if (success) {
		dataStoreInfo->setIsSingleStructure(true);
	}
	
	return result;
}


/* FUNCTION: readMMP */
bool NanorexMMPImportExport::readMMP(istream& instream,
                                     NXMoleculeSet *rootMoleculeSetPtr)
{
	reset();
	
	p = RagelIstreamPtr(instream);
	pe = RagelIstreamPtr(instream, 0, ios::end);
	eof = pe;
	
	molSetPtr = rootMoleculeSetPtr;
	// molSetPtrStack.push(molSetPtr);
	
    /// @todo handle first 'group' statement and molSetPtrStack initialization
	
    // Ragel parser implementation
	bool success = true;
	%% write exec;
	
    // End-of-parsing sanity checks
	if(molSetPtrStack.size() != 0) {
		NXLOG_WARNING("NanorexMMPImportExport",
		              "At least one group has no matching egroup statement");
	}
	return success;
}


/* FUNCTION: createNewMoleculeSet */
void NanorexMMPImportExport::createNewMoleculeSet(void)
{
	if(molSetPtr != NULL) {
		NXMoleculeSet *newMolSetPtr = new NXMoleculeSet;
		newMolSetPtr->setTitle(stringval);
		molSetPtr->addChild(newMolSetPtr);
		molSetPtrStack.push(newMolSetPtr);
		molSetPtr = newMolSetPtr;
	}
}


/* FUNCTION: closeMoleculeSet */
void NanorexMMPImportExport::closeMoleculeSet(void)
{
	molSetPtrStack.pop();
	molSetPtr = (molSetPtrStack.size() == 0) ? NULL : molSetPtrStack.top();
}


/* FUNCTION: createNewMolecule */
inline void NanorexMMPImportExport::createNewMolecule(void)
{ 
	atomPtr = NULL;
	bondPtr = NULL;
	molPtr = NULL;
	molPtr = molSetPtr->newMolecule();
}


/* FUNCTION: applyAtomType */
void NanorexMMPImportExport::applyAtomType(string const& keyStr,
                                           string const& valueStr)
{
	if(molPtr != NULL && atomPtr != NULL) {
		if(keyStr == "atomtype") { // hybridization info
			if(valueStr == "sp") atomPtr->SetHyb(1);
			else if(valueStr == "sp2") atomPtr->SetHyb(2);
			else if(valueStr == "sp2_g") atomPtr->SetHyb(2);
			else if(valueStr == "sp3") atomPtr->SetHyb(3);
			else if(valueStr == "sp3d") atomPtr->SetHyb(3);
            // else ignore
		}
	}
}




/* FUNCTION: exportToFile */
NXCommandResult*
NanorexMMPImportExport::
exportToFile(NXMoleculeSet *molSetPtr,
             NXDataStoreInfo */*dataStoreInfo*/,
             const std::string& theFilename,
             int /*frameSetId*/, int /*frameIndex*/)
{
	NXCommandResult *result = new NXCommandResult();
	result->setResult(NX_CMD_SUCCESS);
	
	ofstream mmpfile(theFilename.c_str(), ios::out);
	if(!mmpfile) {
		populateCommandResult(result,
		                      (string("Couldn't open file: ") + theFilename)
		                      .c_str());
	}
	else {
		PrintMoleculeSet(mmpfile, molSetPtr);
		mmpfile.close();
	}
	return result;
}


/* FUNCTION: GetAtomID */
/* static */
int NanorexMMPImportExport::GetAtomID(OBAtom *atomPtr)
{
	NXAtomData *atomIDData = 
		static_cast<NXAtomData*>(atomPtr->GetData(NXAtomDataType));
	int atomID = atomIDData->GetIdx();
	return atomID;
}


/* FUNCTION: GetAtomRenderStyleCode */
/* static */
string const&
NanorexMMPImportExport::GetAtomRenderStyleCode(OBAtom *const atomPtr)
{
	NXAtomData *atomDataPtr =
		static_cast<NXAtomData*>(atomPtr->GetData(NXAtomDataType));
	string const& atomStyle = atomDataPtr->GetRenderStyleCode();
	return atomStyle;
}


/* FUNCTION: PrintMolecule */
/* static */
void NanorexMMPImportExport::PrintMolecule(ostream& o,
                                           OBMol *const molPtr)
{
	set<int> prevAtomIdx;
	set<int> prevBondIdx; /// @todo - replace with simple bond count
	
	o << "mol (" << molPtr->GetTitle() << ')' << endl;
	
	OBAtomIterator atomIter;
	OBAtom *atomPtr = NULL;
    // For each atom ...
	for(atomPtr = molPtr->BeginAtom(atomIter);
	    atomPtr != NULL;
	    atomPtr = molPtr->NextAtom(atomIter))
	{
        // ... write the 'atom' line ...
		int atomID = GetAtomID(atomPtr);
		o << "atom " << atomID << " (" << atomPtr->GetAtomicNum() << ") " << '('
			<< atomPtr->x() << ',' << atomPtr->y() << ',' << atomPtr->z()
			<< ") " << GetAtomRenderStyleCode(atomPtr) << endl;
		
		if(atomPtr->GetHyb() != 0) {
			o << "info atom atomtype = "
				<< _s_hybridizationName[atomPtr->GetHyb()];
		}
		
        // ... write the 'bond' lines for this atom ...
        // ... first sort bonds by type ...
		OBBondIterator bondIter;
		OBBond *bondPtr = NULL;
		vector<int> bondCategories[6];
		for(bondPtr = atomPtr->BeginBond(bondIter);
		    bondPtr != NULL;
		    bondPtr = atomPtr->NextBond(bondIter))
		{
            // write bond statement only if target atom was previously written
			OBAtom *nbrAtomPtr = bondPtr->GetNbrAtom(atomPtr);
			int nbrAtomID = GetAtomID(nbrAtomPtr);
			if(prevAtomIdx.find(nbrAtomID) != prevAtomIdx.end()) {
				int bondOrder = bondPtr->GetBondOrder();
				bondCategories[bondOrder-1].push_back(nbrAtomID);
                // record bond for sanity check at end
				prevBondIdx.insert(bondPtr->GetIdx());
			}
		}
		
        // ... write the bonds, one line per type ...
		for(int i=0; i<6; ++i) {
			int J = bondCategories[i].size();
			if(J > 0) {
				o << "bond" << _s_bondOrderString[i];
				for(int j=0; j<J; ++j)
					o << ' ' << bondCategories[i][j];
				o  << endl;
			}
		}
		
        // record atom as 'previously written'
		prevAtomIdx.insert(atomID);
	}
	
    // debug diagnostics
	ostringstream debugMsg;
	debugMsg << "# atoms check ";
	if(molPtr->NumAtoms() == prevAtomIdx.size())
		debugMsg << "PASS ("  << molPtr->NumAtoms() << ')' << endl;
	else
		debugMsg << "FAIL: "
		<< molPtr->NumAtoms() << " != " << prevAtomIdx.size()<< endl;
	
	debugMsg << "# bonds check ";
	if(molPtr->NumBonds() == prevBondIdx.size())
		debugMsg << "PASS (" << molPtr->NumBonds() << ')' << endl;
	else
		debugMsg << "FAIL: "
		<< molPtr->NumBonds() << " != " << prevBondIdx.size()<< endl;
	
	debugMsg.flush();
	NXLOG_DEBUG("NanorexMMPImportExport::PrintMoleculeSet",
	            debugMsg.str().c_str());
}


/* FUNCTION: PrintMoleculeSet */
/* static */
void NanorexMMPImportExport::PrintMoleculeSet(ostream& o,
                                              NXMoleculeSet *const molSetPtr)
{
	// Iterate over all child molecules
	OBMolIterator molIter;
	for(molIter = molSetPtr->moleculesBegin();
	    molIter != molSetPtr->moleculesEnd();
	    ++molIter)
	{
		PrintMolecule(o, *molIter);
	}
	
    // Iterate over all child molecule sets
	NXMoleculeSetIterator molSetIter;
	for(molSetIter = molSetPtr->childrenBegin();
	    molSetIter != molSetPtr->childrenEnd();
	    ++molSetIter)
	{
		PrintMoleculeSet(o, *molSetIter);
	}
}


/* FUNCTION: populateCommandResult */
void
NanorexMMPImportExport::populateCommandResult (NXCommandResult* result,
                                               const string& message)
{
	result->setResult(NX_PLUGIN_REPORTS_ERROR);
	vector<QString> resultVector;
	resultVector.push_back("OpenBabelImportExport");
	resultVector.push_back(message.c_str());
	result->setParamVector(resultVector);
}

Q_EXPORT_PLUGIN2 (NanorexMMPImportExport, NanorexMMPImportExport)

