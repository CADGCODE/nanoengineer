# Copyright 2004-2007 Nanorex, Inc.  See LICENSE file for details. 
"""
selectAtomsMode.py 

$Id$



History:

Some things that need cleanup in this code [bruce 060721 comment]: ####@@@@
- redundant use of glRenderMode (see comment where that is used)

- drag algorithms for various object types and modifier keys are split over lots of methods
with lots of common but not identical code. For example, a set of atoms and jigs can be dragged
in the same way, by two different pieces of code depending on whether an atom or jig in the set
was clicked on. If this was cleaned up, so that objects clicked on would answer questions about
how to drag them, and if a drag_handler object was created to handle the drag (or the object itself
can act as one, if only it is dragged and if it knows how), the code would be clearer, some bugs
would be easier to fix, and some NFRs easier to implement. [bruce 060728 -- I'm adding drag_handlers
for use by new kinds of draggable or buttonlike things (only in selectAtoms mode and subclasses),
but not changing how old dragging code works.]

- Ninad 070216 split this out of selectMode.py 

"""




from OpenGL.GLU import gluProject

from PyQt4.Qt import QMouseEvent

import env

from VQT import V
from chem import Atom
from jigs import Jig
from bonds import Bond
from debug import print_compact_traceback
from modes import basicMode
from Utility import Group

from elements import Singlet

from selectMode import selectMode
from selectMode import debug_update_selobj_calls
from selectMode import set_DRAG_STICKINESS_LIMIT_from_pref
from selectMode import DRAG_STICKINESS_LIMIT

from debug import print_compact_stack
from debug_prefs import debug_pref, Choice_boolean_True

from constants import darkred
from constants import black

from prefs_constants import bondHighlightColor_prefs_key
from prefs_constants import bondpointHighlightColor_prefs_key
from prefs_constants import atomHighlightColor_prefs_key

class selectAtomsMode(selectMode):
    modename = 'SELECTATOMS'
    default_mode_status_text = "Mode: Select Atoms"
    highlight_singlets = False 
        # Don't highlight singlets in selectAtomsMode. Fixes bug 1540. mark 060220.
    water_enabled = False # Fixes bug 1583. mark 060301.
        
    eCCBtab1 = [1,2, 5,6,7,8,9,10, 13,14,15,16,17,18, 32,33,34,35,36, 51,52,53,54]
        
    def __init__(self, glpane):
        selectMode.__init__(self, glpane)
            
    def Enter(self): 
        selectMode.Enter(self)        
        self.o.assy.permit_pick_atoms()
        self.w.win_update() #k needed? I doubt it, I bet caller of Enter does it [bruce comment 050517, moved here 060721]
        
        # Reinitialize previously picked atoms (ppas).
        self.o.assy.ppa2 = self.o.assy.ppa3 = None
        
        self.o.selatom = None
        self.reset_drag_vars()
        self.dont_update_gui = True # until changed in init_gui
        self.ignore_next_leftUp_event = False
            # Set to True in leftDouble() and checked by the left*Up() event handlers
            # to determine whether they should ignore the (second) left*Up event
            # generated by the second LMB up/release event in a double click.
	    
    def reset_drag_vars(self):
        """
        Overrides L{selectMode.reset_drag_vars}
        """
	selectMode.reset_drag_vars(self)
	
        self.smooth_reshaping_drag = False
            # set to True when we're going to do a "smooth-reshaping drag" in 
	    #the current drag. [bruce 070412]
            ###WARNING: this method is in selectAtomsMode.py in Qt3 branch, and 
	    ##in selectMode.py in Qt4 branch.
            # When merging this change from Qt3 to Qt4, this specific part will 
	    # need manual merging
            # (unless this entire method is first moved over in Qt3, but that 
	    #  might complicate the merging as well, in the short run, though 
	    # it would be a good change in the longer run).

    def init_gui(self):
        selectMode.init_gui(self)
        self.w.toolsSelectAtomsAction.setChecked(1) # toggle on the "Select Atoms" tools icon
        self.connect_or_disconnect_signals(True)
        
    def connect_or_disconnect_signals(self, connect):
        """
	Subclasses should override this method
	"""
	pass
    
    def set_selection_filter(self, enabled):
	''' Set/ Unset selection filter. Subclasses should override this
	@param: enabled: boolean that decides whether to turn 
	selection filter on or off. '''
	pass 

    def restore_gui(self):
        # disconnect signals which were connected in init_gui [bruce 050728]
        self.connect_or_disconnect_signals(False)
            
    def bareMotion(self, event): #bruce 050610 revised this
        """called for motion with no button down
        [should not be called otherwise -- call update_selatom or update_selobj directly instead]
        """
    
        # The mouse_exceeded_distance() conditional below is a "hover highlighting" optimization. 
        # It works by returning before calling update_selobj() if the mouse is moving fast. 
        # This reduces unnecessary highlighting of objects whenever the user moves the cursor 
        # quickly across the GLPane. In many cases, this unnecessary highlighting degrades 
        # interactive responsiveness and can also cause the user to select the wrong objects (i.e. atoms), 
        # especially in large models.
        #
        # One problem with this approach (pointed out by Bruce) happens when the user moves the
        # cursor quickly from one object and suddenly stops on another object, expecting it (the 2nd 
        # object) to be highlighted. Since bareMotion() is only called when the mouse is moving, and the
        # distance between the last two mouse move events is far, mouse_exceed_distance() will 
        # return True. In that case, update_selobj() will not get called and the object under the cursor 
        # will never get highlighted unless the user jiggles the mouse slightly. To address this issue, 
        # a GLpane timer was implemented. The timer calls bareMotion() whenever it expires and the 
        # cursor hasn't moved since the previous timer event. For more details, read the docstring for 
        # GLPane.timerEvent().
        if self.mouse_exceeded_distance(event, 1):
            return
        
        self.update_selobj(event)
        # note: this routine no longer updates glpane.selatom. For that see self.update_selatom().
        ###e someday, if new or prior selobj asks for it (by defining certain methods), we'd tell it about this bareMotion
        # and about changes in selobj. [bruce 060726]
        return

    def get_obj_under_cursor(self, event): # docstring appears wrong
        """
        Return the object under the cursor.  Only atoms, singlets and bonds are returned.
        Returns None for all other cases, including when a bond, jig or nothing is under the cursor.
        """
        ### WARNING: this method is defined in two places, with mostly duplicated code,
        # but with one key difference whose date, author, & purpose is not documented.
        # [bruce 070924 comment]
        #

        #bruce 060331 comment: this docstring appears wrong, since the code looks like it can return jigs.
        #bruce 070322 note: this will be overridden (extended) in testmode, which will sometimes return a "background object"
        # rather than None, in order that leftDown can be handled by background_object.leftClick in the same way as for
        # other drag_handler-returning objects.
        #
        ### WARNING: this is slow, and redundant with highlighting -- only call it on mousedown or mouseup, never in move or drag.
        # [true as of 060726 and before; bruce 060726 comment]
        # It may be that it's not called when highlighting is on, and it has no excuse to be, but I suspect it is anyway.
        # [bruce 060726 comment]
        if self.hover_highlighting_enabled:
            self.update_selatom(event) #bruce 041130 in case no update_selatom happened yet
            # update_selatom() updates self.o.selatom and self.o.selobj.
            # self.o.selatom is either a real atom or a singlet [or None].
            # self.o.selobj can be a bond, and is used in leftUp() to determine if a bond was selected.
            
            # Warning: if there was no GLPane repaint event (i.e. paintGL call) since the last bareMotion,
            # update_selatom can't make selobj/selatom correct until the next time paintGL runs.
            # Therefore, the present value might be out of date -- but it does correspond to whatever
            # highlighting is on the screen, so whatever it is should not be a surprise to the user,
            # so this is not too bad -- the user should wait for the highlighting to catch up to the mouse
            # motion before pressing the mouse. [bruce 050705 comment] [might be out of context, copied from other code]
        
            obj = self.o.selatom # a "highlighted" atom or singlet
            
            if obj is None and self.o.selobj:
                obj = self.o.selobj # a "highlighted" bond
                    # [or anything else, except Atom or Jig -- i.e. a general/drag_handler/Drawable selobj [bruce 060728]]
                if env.debug():
                    # I want to know if either of these things occur -- I doubt they do, but I'm not sure about Jigs [bruce 060728]
                    # (this does happen for Jigs, see below)
                    if isinstance(obj, Atom):
                        print "debug fyi: likely bug: selobj is Atom but not in selatom: %r" % (obj,)
                    elif isinstance(obj, Jig):
                        print "debug fyi: selobj is a Jig in get_obj_under_cursor (comment is wrong), for %r" % (obj,)
                        # I suspect some jigs can occur here
                        # (and if not, we should put them here -- I know of no excuse for jig highlighting
                        #  to work differently than for anything else) [bruce 060721]
                        # update 070413: yes, this happens (e.g. select some atoms and an rmotor jig, then drag the jig).
                    pass
            
            if obj is None: # a "highlighted" jig [i think this comment is misleading, it might really be nothing -- bruce 060726]
                obj = self.get_jig_under_cursor(event) # [this can be slow -- bruce comment 070322]
                if 0 and env.debug():
                    print "debug fyi: get_jig_under_cursor returns %r" % (obj,) # [bruce 060721] 
            pass
            
        else: # No hover highlighting
            obj = self.o.assy.findAtomUnderMouse(event, self.water_enabled, singlet_ok = True)
            # Note: findAtomUnderMouse() only returns atoms and singlets, not bonds or jigs.
            # This means that bonds can never be selected when highlighting is turned off.
            # [What about jigs? bruce question 060721]
        return obj
            
    def get_real_atom_under_cursor(self, event):
        '''If the object under the cursor is a real atom, return it.  Otherwise, return None.
        '''
        obj = self.get_obj_under_cursor(event)
        if isinstance(obj, Atom):
            if not obj.is_singlet():
                return obj
        return None

    def bond_type_changer_is_active(self): #bruce 060702
        "[subclasses can override this; see depositMode implem for docstring]"
        return False

    def selobj_highlight_color(self, selobj): #bruce 050612 added this to mode API
        """[mode API method]
        If we'd like this selobj to be highlighted on mouseover
        (whenever it's stored in glpane.selobj), return the desired highlight color.
        If we'd prefer it not be highlighted (though it will still be stored
        in glpane.selobj and prevent any other objs it obscures from being stored there
        or highlighted), return None. (Warning: exceptions are ignored and cause the
        default highlight color to be used. #e should clean that up sometime)
        """
        
        if not self.hover_highlighting_enabled:
            return None

        #####@@@@@ if self.drag_handler, we should probably let it override all this
        # (so it can highlight just the things it might let you DND its selobj to, for example),
        # even for Atom/Bondpoint/Bond/Jig, maybe even when not self.hover_highlighting_enabled. [bruce 060726 comment]
        
        if isinstance(selobj, Atom):
            if selobj.is_singlet():
                if self.highlight_singlets: # added highlight_singlets to fix bug 1540. mark 060220.
                    likebond = self.bond_type_changer_is_active() #bruce 060702 part of fixing bug 833 item 1
                    if likebond:
                        # clicks in this tool-state modify the bond, not the bondpoint, so let the color hint at that
                        return env.prefs[bondHighlightColor_prefs_key]
                    else:
                        return env.prefs[bondpointHighlightColor_prefs_key]
                else:
                    return None
            else:
                if self.only_highlight_singlets: # True only when dragging a bondpoint (in Build mode).
                    # Highlight this atom if it has bondpoints.
                    if selobj.singNeighbors():
                        if self.current_obj in selobj.singNeighbors(): 
                            # Do not highlight the atom that the current singlet belongs to.
                            # Fixes bug 1522. mark 060301.
                            return None
                        return env.prefs[atomHighlightColor_prefs_key]
                            # Possible bug: bruce 070413 seems to observe this not working except when the mouse goes over
                            # the end of a bond attached to that atom (which counts as the atom for highlighting),
                            # or when the atom is already highlighted. (Could it be the cursor going over the rubberband
                            # line? Not always. But it might be intermittent.)
                    elif selobj.element.symbol == 'Sh':
                        ##e and isinstance(self.current_obj, Atom), and is_singlet, and its neighbor is a Pl:
                        # bruce 070413 KLUGE: make new depositMode behavior in (a specialcase of) this case possible
                        ###e [needs to be generalized, and made so that only one place needs to know this condition;
                        # note that the above is not the complete condition since i got lazy (and this NFR is urgent)]
##                        if env.debug():
##                            print "highlighting Sh like a bondpoint"
                        return env.prefs[bondpointHighlightColor_prefs_key] # look like bondpoint, since treated as one
                    else:
                        return None
                if self.o.modkeys == 'Shift+Control':
                    return darkred  
                        # Highlight the atom in darkred if the control key is pressed and it is not picked.
                        # The delete_mode color should be a user pref.  Wait until A8, though.  mark 060129.
                else:
                    return env.prefs[atomHighlightColor_prefs_key]
        elif isinstance(selobj, Bond):
            #bruce 050822 experiment: debug_pref to control whether to highlight bonds
            # (when False they'll still obscure other things -- need to see if this works for Mark ###@@@)
            # ###@@@ PROBLEM with this implem: they still have a cmenu and can be deleted by cmd-del (since still in selobj);
            # how would we *completely* turn this off? Need to see how GLPane decides whether a drawn thing is highlightable --
            # maybe just by whether it can draw_with_abs_coords? Maybe by whether it has a glname (not toggleable instantly)?
            # ... now i've modified GLPane to probably fix that...
            highlight_bonds = debug_pref("highlight bonds", Choice_boolean_True)
            if not highlight_bonds:
                return None
            ###@@@ use checkbox to control this; when false, return None
            if selobj.atom1.is_singlet() or selobj.atom2.is_singlet():
                # this should never happen, since singlet-bond is part of singlet for selobj purposes [bruce 050708]
                print "bug: selobj is a bond to a bondpoint, should have borrowed glname from that bondpoint", selobj
                    #bruce 060726 revised this
                return None # precaution
            else:
                if self.only_highlight_singlets:
                    return None
                if self.o.modkeys == 'Shift+Control': 
                    return darkred
                else:
                    return env.prefs[bondHighlightColor_prefs_key]
        elif isinstance(selobj, Jig): #bruce 050729 bugfix (for some bugs caused by Huaicai's jig-selection code)
            if not self.o.jigSelectionEnabled: #mark 060312.
                # jigSelectionEnabled set from GLPane context menu.
                return None
            if self.o.modkeys == 'Shift+Control': 
                return darkred
            else:
                return env.prefs[bondHighlightColor_prefs_key]
        else:
            if 1:
                # Let the object tell us its highlight color, if it's not one we have a special case for here
                # (and if no drag_handler told us instead (nim, above)).
                # Note: this color will be passed to selobj.draw_in_abs_coords when selobj is asked
                # to draw its highlight; but even if that method plans to ignore that color arg,
                # this method better return a real color (or at least not None or (maybe) anything false),
                # otherwise GLPane will decide it's not a valid selobj and not highlight it at all.
                # (And in that case, will a context menu work on it (if it wasn't nim for that kind of selobj)?
                #  I don't know.)
                # [bruce 060722 new feature; revised comment 060726]
                method = getattr(selobj, 'highlight_color_for_modkeys', None)
                if method:
                    return method(self.o.modkeys)
                        # Note: this API might be revised; it only really makes sense if the mode created the selobj to fit its
                        # current way of using modkeys, perhaps including not only its code but its active-tool state.
                        #e Does it make sense to pass the drag_handler, even if we let it override this?
                        # Yes, since it might like to ask the object (so it needs an API to do that), or let the obj decide,
                        # based on properties of the drag_handler.
                        #e Does it make sense to pass the obj being dragged without a drag_handler?
                        # Yes, even more so. Not sure if that's always called the same thing, depending on its type.
                        # If not, we can probably just kluge it by self.this or self.that, if they all get reset each drag. ###@@@
            print "unexpected selobj class in mode.selobj_highlight_color:", selobj
            return black ## bruce 060726 blue -> black so the fact that it's an error is more obvious
        
        pass # end of selobj_highlight_color
    
        
        
    def update_selatom(self, 
                       event, 
                       singOnly = False, 
                       msg_about_click = False, 
                       resort_to_prior = True):
        """
        Keep selatom up-to-date, as atom under mouse based on <event>; 
        When <singOnly> is True, only keep singlets up-to-date. 
        [not sure what that phrase means -- bruce 060726]
        When <msg_about_click> is True, print a message on the statusbar 
        about the LMB press.
        <resort_to_prior> is disabled. 
        [that statement seems incorrect -- bruce 060726]
        ###@@@ correctness after rewrite not yet proven, 
        due to delay until paintGL
        """
        #bruce 050124 split this out of bareMotion so options can vary
        #bruce 050610 rewrote this
        #bruce 060726 comment: looks to me like docstring is wrong about 
        #                      resort_to_prior, and some comments are obs.
        # Note: it never changes glpane.selobj.
        glpane = self.o
        if event is None:
            # event (and thus its x,y position) is not known [bruce 050612 added this possibility]
            known = False
        else:
            known = self.update_selobj(event) # this might do gl_update (but the paintGL triggered by that only happens later!),
                # and (when it does) might not know the correct obj...
                # so it returns True iff it did know the correct obj (or None) to store into glpane.selobj, False if not.
        assert known in [False,True], "known should be False or True, not %r" % (known,) #bruce 070224 added message to assert
        # If not known, use None or use the prior one? This is up to the caller
        # since the best policy varies. Default is resort_to_prior = True since some callers need this
        # and I did not yet scan them all and fix them. ####@@@@ do that
        
        selobj = glpane.selobj
        
                            
        if not known:
            if resort_to_prior: 
                pass # stored one is what this says to use, and is what we'll use
                ## print "resort_to_prior using",glpane.selobj
                    # [this is rare, I guess since paintGL usually has time to run after bareMotion before clicks]
            else:
                selobj = None
        oldselatom = glpane.selatom
        atm = selobj
        if not isinstance(atm, Atom):
            atm = None
        if atm is not None and (atm.element is Singlet or not singOnly):
            pass # we'll use this atm as the new selatom
        else:
            atm = None # otherwise we'll use None
        glpane.selatom = atm
        
        if msg_about_click: # [always do this, since many things can change what it should say]
            # come up with a status bar message about what we would paste now.
            # [bruce 050124 new feature, to mitigate current lack of model tree highlighting of pastable]
            msg = self.describe_leftDown_action( glpane.selatom)
            env.history.statusbar_msg( msg)
        if glpane.selatom is not oldselatom:
            # update display (probably redundant with side effect of update_selobj; ok if it is, and I'm not sure it always is #k)
            glpane.gl_update_highlight() # draws selatom too, since its chunk is not hidden [comment might be obs, as of 050610]
        
        return # from update_selatom

    
        
# == LMB event handling methods ====================================
#
# The following sections include all the LMB event handling methods for selectAtomsMode
# The section is organized in the following order and includes the following methods:
#
#   - LMB down-click (button press) methods
#       leftShiftDown()
#       leftCntlDown()
#       leftDown()
#
#   - LMB drag methods
#       leftShiftDrag()
#       leftDrag()
# 
#   - LMB up-click (button release) methods
#       leftShiftUp()
#       leftCntlUp()
#       leftUp()
#
#   - LMB double-click method (only one)
#       leftDouble()
#
# For more information about the LMB event handling scheme, go to 
# http://www.nanoengineer-1.net/ and click on the "Build Mode UI Specification" link.
        
# == LMB down-click (button press) methods

    def leftShiftDown(self, event):
        '''Event handler for Shift+LMB press.'''
        self.leftDown(event)
    
    def leftCntlDown(self, event):
        '''Event handler for Control+LMB press.'''
        self.leftDown(event)
    
    def leftDown(self, event):
        '''Event handler for all LMB press events.'''

        self.set_cmdname('BuildClick') #e (this should be set again later (during the same drag) to a more specific command name)
        
        self.o.assy.permit_pick_atoms() # Fixes bug 1413, 1477, 1478 and 1479.  Mark 060218.
        self.reset_drag_vars()
        env.history.statusbar_msg(" ") # get rid of obsolete msg from bareMotion [bruce 050124; imperfect #e]
            
        self.LMB_press_event = QMouseEvent(event) # Make a copy of this event and save it. 
            # We will need it later if we change our mind and start selecting a 2D region in leftDrag().
            # Copying the event in this way is necessary because Qt will overwrite <event> later (in 
            # leftDrag) if we simply set self.LMB_press_event = event.  mark 060220.

        #bruce 060315 replacing LMB_press_pt with LMB_press_pt_xy
        self.LMB_press_pt_xy = (event.pos().x(), event.pos().y())
            # <LMB_press_pt_xy> is the position of the mouse in window coordinates when the LMB was pressed.
            # Used in mouse_within_stickiness_limit (called by leftDrag() and other methods).
            # We don't bother to vertically flip y using self.height (as mousepoints does),
            # since this is only used for drag distance within single drags.
            
        obj = self.get_obj_under_cursor(event)
            # If highlighting is turned on, get_obj_under_cursor() returns atoms, singlets, bonds, jigs,
            # or anything that can be highlighted and end up in glpane.selobj. [bruce revised this comment, 060725]
            # (It can also return a "background object" from testmode, as of bruce 070322.)
            # If highlighting is turned off, get_obj_under_cursor() returns atoms and singlets (not bonds or jigs).
            # [not sure if that's still true -- probably not. bruce 060725 addendum]
        
        if obj is None: # Cursor over empty space.
            self.emptySpaceLeftDown(event)
            return

        if 1:
            #bruce 060725 new feature. Any selobj can decide how clicks/drags on it should behave, if it wants to.
            # Normally this will not apply to an Atom, Bond, or Jig, but there's no reason it couldn't in theory.
            # The API is experimental and is very likely to be modified, so don't depend on it yet.
            # (But note that testmode and the exprs module do depend on it.)
            # For example, we're likely to tell it some modkeys, something about this mode, the mousepoints, etc,
            # and to respond more fundamentally to whatever is returned. ###@@@
            # (see also mouseover_statusbar_message, used in GLPane.set_selobj)
            method = getattr(obj, 'leftClick', None)
            if method:
                ## farQ_junk, hitpoint = self.dragstart_using_GL_DEPTH( event) ###k safe?
                gl_event_info = self.dragstart_using_GL_DEPTH( event, more_info = True) #bruce 061206 revised this, adding more_info
                self._drag_handler_gl_event_info = gl_event_info 
                farQ_junk, hitpoint, wX, wY, depth, farZ = gl_event_info
                del wX, wY, depth, farZ
                try:
                    retval = method(hitpoint, event, self) ##e more args later -- mouseray? modkeys? or use callbacks to get them?
                        #bruce 061120 changed args from (hitpoint, self) to (hitpoint, event, self) [where self is the mode object]
                        # a new part of the drag_handler API is access by method to self._drag_handler_gl_event_info [bruce 061206]
                        #e (we might decide to change that to a dict so it's easily extendable after that, or we might add more attrs
                        #   or methods of self which the method call is specifically allowed to access as part of that API #e)
                except:
                    print_compact_traceback("exception ignored in %r.leftClick: " % (obj,))
                    return # no update or other action here
                # If retval is None, the object just wanted to know about the click, and now we handle it normally
                # (including the usual special cases for Atom, etc).
                # If retval is a drag handler (#doc), we let that object handle everything about the drag.
                # (Someday, all of our object/modkey-specific code should be encapsulated into drag handlers.)
                # If retval is something else... not sure, so nevermind for now, just assume it's a drag handler. ###@@@
                self.drag_handler = retval # needed even if this is None
                    ##e should wrap with something which exception-protects all method calls
                if self.drag_handler is not None:
                    # We're using a drag_handler to override most of our behavior for this drag.
                    self.dragHandlerSetup(self.drag_handler, event) # does updates if needed
                    # don't do the rest of this method:
                    return

        if isinstance(obj, Atom) and obj.is_singlet(): # Cursor over a singlet
            self.singletLeftDown(obj, event)
                # no win_update() needed. It's the responsibility of singletLeftDown to do it if needed.
            return
            
        elif isinstance(obj, Atom) and not obj.is_singlet(): # Cursor over a real atom
            self.atomLeftDown(obj, event)
        
        elif isinstance(obj, Bond) and not obj.is_open_bond(): # Cursor over a bond.
            self.bondLeftDown(obj, event)
        
        elif isinstance(obj, Jig): # Cursor over a jig.
            self.jigLeftDown(obj, event)

        else: # Cursor is over something else other than an atom, singlet or bond. 
            # The program never executes lines in this else statement since
            # get_obj_under_cursor() only returns atoms, singlets or bonds.
            # [perhaps no longer true, if it ever was -- bruce 060725]
            pass

        self.w.win_update() #k (is this always desirable? note, a few cases above return early just so they can skip it.)
        return # from selectAtomsMode.leftDown

# == LMB drag methods

    def leftShiftDrag(self, event):
        '''Event handler for Shift+LMB+Drag.'''
        self.leftDrag(event)
        
    def leftCntlDrag(self, event):
        '''Event handler for Control+LMB+Drag.'''
        self.leftDrag(event)
        
    def leftDrag(self, event):
        '''Event handler for all LMB+Drag events.'''
        
        # Do not change the order of the following conditionals unless you know
        # what you're doing.  mark 060208.
        
        if self.mouse_within_stickiness_limit(event, DRAG_STICKINESS_LIMIT):
            # [let this happen even for drag_handlers -- bruce 060728]
            return
        
        if self.cursor_over_when_LMB_pressed == 'Empty Space':
            if self.drag_handler is not None:
##                print "possible bug (fyi): self.drag_handler is not None, but cursor_over_when_LMB_pressed == 'Empty Space'", \
##                      self.drag_handler #bruce 060728
                # bruce 070322: this is permitted now, and we let the drag_handler handle it (for testmode & exprs module)...
                # however, I don't think this new feature will be made use of yet, since testmode will instead sometimes
                # override get_obj_under_cursor to make it return a background object rather than None,
                # so this code will not set cursor_over_when_LMB_pressed to 'Empty Space'.
                self.dragHandlerDrag(self.drag_handler, event) # does updates if needed
            else:
                self.emptySpaceLeftDrag(event)
            return
            
        if self.o.modkeys is not None:
            # If a drag event has happened after the cursor was over an atom and a modkey is pressed,
            # do a 2D region selection as if the atom were absent.
            # [let this happen even for drag_handlers -- bruce 060728]
            self.emptySpaceLeftDown(self.LMB_press_event)
            #bruce 060721 question: why don't we also do emptySpaceLeftDrag at this point?
            return

        if self.drag_handler is not None:
            #bruce 060728
            self.dragHandlerDrag(self.drag_handler, event) # does updates if needed
            return
        
        obj = self.current_obj
        
        if obj is None: # Nothing dragged (or clicked); return.
            return
        
        if isinstance(obj, Atom):
            if obj.is_singlet(): # Bondpoint
                self.singletDrag(obj, event)
            else: # Real atom
                self.atomDrag(obj, event)
        
        elif isinstance(obj, Bond): # Bond
            self.bondDrag(obj, event)
        
        elif isinstance(obj, Jig): # Jig
            self.jigDrag(obj, event)
        
        else: # Something else
            pass
            
        # No gl_update() needed. Already taken care of.
        return
        
    def posn_str(self, atm): #bruce 041123
        """return the position of an atom
        as a string for use in our status messages
        (also works if given an atom's position vector itself -- kluge, sorry)
        """
        try:
            x,y,z = atm.posn()
        except AttributeError:
            x,y,z = atm # kluge to accept either arg type
        return "(%.2f, %.2f, %.2f)" % (x,y,z)
        
# == LMB up-click (button release) methods

    def leftShiftUp(self, event):
        '''Event handler for Shift+LMB release.'''
        self.leftUp(event)
    
    def leftCntlUp(self, event):
        '''Event handler for Control+LMB release.'''
        self.leftUp(event)
    
    def leftUp(self, event):
        '''Event handler for all LMB release events.'''
        env.history.flush_saved_transients() # flush any transient message it saved up
        
        if self.ignore_next_leftUp_event: # This event is the second leftUp of a double click, so ignore it.
            self.ignore_next_leftUp_event = False
            self.update_selobj(event) # Fixes bug 1467. mark 060307.
            return
        
        if self.cursor_over_when_LMB_pressed == 'Empty Space':
            self.emptySpaceLeftUp(event)
            return
        
        if self.mouse_within_stickiness_limit(event, DRAG_STICKINESS_LIMIT):
            event = self.LMB_press_event
                # pretend the mouse didn't move -- this replaces our argument event,
                # for passing to *leftUp methods [bruce 060728 comment]

        if self.drag_handler:
            #bruce 060728
            self.dragHandlerLeftUp(self.drag_handler, event) # does updates if needed
            self.leftUp_reset_a_few_drag_vars() #k needed??
            return
        
        obj = self.current_obj
            
        if obj is None: # Nothing dragged (or clicked); return.
            return
            
        if isinstance(obj, Atom):
            if obj.is_singlet(): # Bondpoint
                self.singletLeftUp(obj, event)
            else: # Real atom
                self.atomLeftUp(obj, event)
            
        elif isinstance(obj, Bond): # Bond
            self.bondLeftUp(obj, event)
            
        elif isinstance(obj, Jig): # Jig
            self.jigLeftUp(obj, event)
        
        else:
            pass
        
        self.leftUp_reset_a_few_drag_vars()
        #bruce 041130 comment: it forgets selatom, but doesn't repaint,
        # so selatom is still visible; then the next event will probably
        # set it again; all this seems ok for now, so I'll leave it alone.
        #bruce 041206: I changed my mind, since it seems dangerous to leave
        # it visible (seemingly active) but not active. So I'll repaint here.
        # In future we can consider first simulating a update_selatom at the
        # current location (to set selatom again, if appropriate), but it's
        # not clear this would be good, so *this* is what I won't do for now.
        #self.o.gl_update() #& Now handled in modkey*() methods. mark 060210.

        return # from selectAtomsMode.leftUp

    def leftUp_reset_a_few_drag_vars(self): #bruce 060728 split this out, guessed docstring
        "reset a few drag vars at the end of leftUp -- might not be safe to reset them all (e.g. if some are used by leftDouble)"
        self.baggage = []
        self.current_obj = None #bruce 041130 fix bug 230 [later: i guess this attr had a different name then -- bruce 060721]
        self.o.selatom = None #bruce 041208 for safety in case it's killed
        return

# == LMB double-click method

    def leftDouble(self, event): # mark 060126.
        '''Double click event handler for the left mouse button. 
        '''
            
        self.ignore_next_leftUp_event = True
        
        if isinstance(self.obj_doubleclicked, Atom):
            if self.obj_doubleclicked.is_singlet():
                self.singletLeftDouble()
                return
            else:
                self.atomLeftDouble()
            
        if isinstance(self.obj_doubleclicked, Bond):
            self.bondLeftDouble()
            
        if isinstance(self.obj_doubleclicked, Jig):
            self.jigLeftDouble()

# == end of LMB event handler methods
                       
                
    def update_cursor_for_no_MB(self):
        '''Update the cursor for 'Select Atoms' mode (selectAtomsMode)
        '''
        #print "selectAtomsMode.update_cursor_for_no_MB(): button=",self.o.button, ", modkeys=", self.o.modkeys
        
        if self.w.selection_filter_enabled:
            self.update_cursor_for_no_MB_selection_filter_enabled()
        else:
            self.update_cursor_for_no_MB_selection_filter_disabled()
            
    def update_cursor_for_no_MB_selection_filter_disabled(self):
        '''Update the cursor for when the Selection Filter is disabled (default).
        '''
        if self.o.modkeys is None:
            self.o.setCursor(self.w.SelectAtomsCursor)
        elif self.o.modkeys == 'Shift':
            self.o.setCursor(self.w.SelectAtomsAddCursor)
        elif self.o.modkeys == 'Control':
            self.o.setCursor(self.w.SelectAtomsSubtractCursor)
        elif self.o.modkeys == 'Shift+Control':
            self.o.setCursor(self.w.DeleteCursor)
        else:
            print "Error in update_cursor_for_no_MB(): Invalid modkey=", self.o.modkeys
        return
        
    def update_cursor_for_no_MB_selection_filter_enabled(self):
        '''Update the cursor for when the Selection Filter is enabled.
        '''
        if self.o.modkeys is None:
            self.o.setCursor(self.w.SelectAtomsFilterCursor)
        elif self.o.modkeys == 'Shift':
            self.o.setCursor(self.w.SelectAtomsAddFilterCursor)
        elif self.o.modkeys == 'Control':
            self.o.setCursor(self.w.SelectAtomsSubtractFilterCursor)
        elif self.o.modkeys == 'Shift+Control':
            self.o.setCursor(self.w.DeleteFilterCursor) # Fixes bug 1604. mark 060303.
        else:
            print "Error in update_cursor_for_no_MB(): Invalid modkey=", self.o.modkeys
        return
            
    def rightShiftDown(self, event):
        basicMode.rightShiftDown(self, event)
        self.o.setCursor(self.w.SelectAtomsCursor)
           
    def rightCntlDown(self, event):          
        basicMode.rightCntlDown(self, event)
        self.o.setCursor(self.w.SelectAtomsCursor)
        
    def _highlightAtoms(self, grp):
        """Highlight atoms or chunks inside ESPImage jigs."""
        from jigs_planes import ESPImage
            
        if isinstance(grp, ESPImage): 
            grp.highlightAtomChunks()
        elif isinstance(grp, Group):    
            for m in grp.members:
                if isinstance(m, ESPImage):
                    m.highlightAtomChunks()
                elif isinstance(m, Group):
                    self._highlightAtoms(m)
        return
                        
    def Draw(self):
        """Draw the model for Select Atoms mode."""
        selectMode.Draw(self)
        self._highlightAtoms(self.o.assy.part.topnode)
        return

    pass # end of class selectAtomsMode

# end

