== Making MPEGs ==

Google Video accepts the following formats: AVI, MPEG, Quicktime,
Real, and Windows Media. The one I think would be easiest to create on
a Linux box is MPEG. (See http://www.mpeg.org/MSSG/ for codec source
code.) Following advice from distutils, I changed CFLAGS in Makefile
to
  -pthread -fno-strict-aliasing -DNDEBUG -O2 -fomit-frame-pointer \
               -pipe -march=i586 -mtune=pentiumpro  -g -fPIC
and built mpeg2encode and mpeg2decode, and installed them both in /usr/local/bin.

To encode MPEG, you need a parameter file. A good place to start is
par/NTSC.par. Set the number of frames and the input filenames for
your animation. You can change the horizontal and vertical size, but
BOTH must be EVEN NUMBERS. The input filenames can be (*.Y, *.U, *.V)
or *.yuv or *.ppm. I have a Python script for making an MPEG file on
Linux, which I will check into CVS.

I have been assembling a bunch of Python code for this, which for now,
resides in
[http://mirror2.cvsdude.com/~polosims/vcvs/cgi/viewcvs.cgi/cad/src/experimental/animations/
cad/src/experimental/animations].

=== Google Video experiments ===

[http://video.google.com/videoplay?docid=3912306740235211587 Here] is
my first attempt at a MPEG file, posted on Google Video. The problems
with this are that it's fuzzy (I think the resolution was too low),
the aspect ratio is wrong (should be 4:3, I think), and 30 seconds is
a shorter video than I imagined.

My [http://video.google.com/videoplay?docid=-6790724163882599903
second attempt] has a better aspect ratio, but it's still quite fuzzy
inspite of having used a much higher resolution. I suspect Google
Video is downsampling the video for expedient web presentation. Also,
thirty seconds is still just too darn brief.

The fuzziness is because Google downsamples the video when you view it
in your browser. The idea is that viewing the video shouldn't be a big
burden on your network connection.

But then you have the option to download the full-resolution video as
an AVI file, and view it with a local viewer. Then it looks as sharp
as whatever you uploaded, because you're downloading a file at the
full resolution. So higher resolutions aren't completely wasted.

=== Motion blur ===

I have been working on code to generate motion-blurred images as
efficiently as possible. This simulates a multiple exposure in a
camera: each pixel is the averaged value in red, green, and blue of
several individual subframes. These examples are averages of only five
subframes, and they look pretty good. I am getting ready to do a
sequence of 450 frames, each averaging ten subframes, representing 150
picoseconds of simulation time (fifteen seconds of animation time)
with the shaft rotating at 1 GHz to sweep out an angle of about fifty
degrees.

What I've seen so far has been that thermal motion becomes a complete
blur as seen here, but you can clearly see low-frequency modes where
the whole structure moves in some elastic way. This is of course in
addition to the ''intended'' motion, where the shaft rotates within
the casing.

[[Image:Motion blur frame 0.jpg]]

[[Image:Motion blur frame 1.jpg]]

[[Image:Motion blur frame 2.jpg]]
