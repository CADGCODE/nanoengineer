# Copyright (c) 2005 Nanorex, Inc.  All rights reserved.
'''
undo_manager.py

Own and manage an UndoArchive, feeding it info about user-command events
(such as when to make checkpoints and how to describe the diffs generated by user commands),
and package the undo/redo ops it offers into a reasonable UI.

$Id$
'''
__author__ = 'bruce'


from debug import register_debug_menu_command_maker

from undo_archive import UndoArchive
from constants import noop


class UndoManager:
    """[abstract class]
    Own and manage an undo-archive, in such a way as to provide undo/redo operations
    and a current-undo-point within the archive
    on top of state-holding objects which would otherwise not have these undo/redo ops.
       Assume that no other UndoManager or UndoArchive is tracking the same state-holding objects
    (i.e. we own them for undo-related purposes).
       #e future: Perhaps also delegate all command-method-calls to the state-holding objects...
    but for now, tolerate external code directly calling command methods on our state-holding objects,
    just receiving begin/end calls related to those commands and their subroutines or calling event-handlers,
    checkpoint calls from same, and undo/redo command callbacks.
    """
    pass

class AssyUndoManager(UndoManager):
    "An UndoManager specialized for handling the state held by an assy (an instance of class assembly)."
    def __init__(self, assy):
        # assy owns the state whose changes we'll be managing...
        # should it have same undo-interface as eg chunks do??
        ## self.thingies = {}
        self.archive = UndoArchive()
        self.assy = assy
        assy._u_archive = self.archive
            # this is how model objects in assy find something to report changes to (typically in their __init__ methods);
            # we do it here (not in caller) since its name and value are private to our API for model objects to report changes
        return

    def menu_cmd_checkpoint(self):
        self.archive.checkpoint()
        
    def undo_cmds_menuspec(self, widget):
        "return a menu_spec for undo-related commands (to be shown in the given widget, tho i don't know why the widget could matter)"
        ###e include an undo and redo for the current part, and one for the current selection;
        # maybe also a submenu of orthog choices (at most the last 10), called "undo other"??
        # just scan backwards (for undo) and forwards (for redo, no limit on number I think, maybe include all possible redos, old/new)
        # to see what intersects part or sel, and what is doable.
        archive = self.archive
        part = self.assy.part
        sel = part.selection_from_part() #k choice of routine? this includes atoms jigs chunks groups,
            # but selection_from_glpane only atoms and chunks, also _from_MT... ideally we'd depend on the calling widget.
            # in fact, we'd call a method on it (or something related to it, passed instead of it) and ask it for its sel.
##        u1, r1, s1 = archive.undo_menuspecs([part]) ##k??
##        u2, r2, s2 = archive.undo_menuspecs(sel) ###k???
        # let's try out doing it for just the sel, and doing it manually, only for chunks in the sel for now -- TESTING STUB.
        # even ultimately, for selection, tree, etc, only we know which exact objs we care about (and maybe which attrsets in them).
        # so the code to scan the current objs for the ones to include here, is our business.
        state_version = {}
        for obj in sel.selmols:
            moreitems = self.archive.varid_vers_for_obj(obj) ###IMPLEM
            state_version.update(dict(moreitems))
        ops = self.archive.find_undoredos(state_version)
        undos = []
        redos = []
        d1 = {'Undo':undos, 'Redo':redos}
        for op in ops:
            d1[op.type].append(op) # sort ops by type
        # there are at most one per chunk per undoable attr... so for this test, show them all, don't bother with submenus
        res = []
        if not undos:
            res.append(( "Nothing we can Undo", noop, 'disabled' ))
                ###e should figure out whether "Can't Undo XXX" or "Nothing to Undo" is more correct
        ###e sort each list by some sort of time order (maybe of most recent use of the op in either direction??), and limit lengths
        for op in undos + redos:
            # for now, we're not even including them unless as far as we know we can do them, so no role for "Can't Undo" unless none
            model = archive # it's on purpose that op itself has no ref to model, so we have to pass it
            cmd = lambda _guard1_ = None, _guard2_ = None, model = model: op.doit(model) #k guards needed? (does qt pass args to menu cmds?)
            res.append(( "%s %s" % (op.type, op.what()) , cmd ))
        if not redos:
            res.append(( "Nothing we can Redo", noop, 'disabled' ))
        res.append(( 'undo checkpoint (in RAM only)', self.menu_cmd_checkpoint ))
        return res
    pass

# == debugging code - invoke undo/redo from debug menu (only) in initial test implem

def undo_cmds_maker(widget):
    ###e maybe this belongs in assy module itself?? clue: it knows the name of assy.undo_manager; otoh, should work from various widgets
    "[widget is the widget in which the debug menu is being put up right now]"
    #e in theory we use that widget's undo-chain... but in real life this won't even happen inside the debug menu, so nevermind.
    # for now just always use the assy's undo-chain.
    # hmm, how do we find the assy? well, ok, i'll use the widget.
    try:
        assy = widget.win.assy
    except:
        import platform
        if platform.atom_debug:
            return [('atom_debug: no undo in this widget', noop, 'disabled')]
        return []
##    if 'kluge' and not hasattr(assy, 'undo_manager'):
##        assy.undo_manager = UndoManager(assy) #e needs review; might just be a devel kluge, or might be good if arg type is unciv
    mgr = assy.undo_manager #k should it be an attr like this, or a sep func?
    return mgr.undo_cmds_menuspec(widget)

register_debug_menu_command_maker( "undo_cmds", undo_cmds_maker) # fyi: this rins once when the first assy is being created.

# end
