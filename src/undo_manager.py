# Copyright (c) 2005-2006 Nanorex, Inc.  All rights reserved.
'''
undo_manager.py

Own and manage an UndoArchive, feeding it info about user-command events
(such as when to make checkpoints and how to describe the diffs generated by user commands),
and package the undo/redo ops it offers into a reasonable UI.

$Id$

[060117 -- for current status see undo_archive.py module docstring]
'''
__author__ = 'bruce'


from debug import register_debug_menu_command_maker
import platform

from undo_archive import AssyUndoArchive #060117 revised
import undo_archive # for debug_undo2
from constants import noop
import env
from HistoryWidget import orangemsg, greenmsg, redmsg
from debug_prefs import debug_pref, Choice_boolean_True, Choice_boolean_False

class UndoManager:
    """[abstract class] [060117 addendum: this docstring is mostly obsolete or nim]
    Own and manage an undo-archive, in such a way as to provide undo/redo operations
    and a current-undo-point within the archive [addendum 060117: undo point might be in model objects or archive, not here,
      and since objects can't be in more than one archive or have more than one cur state (at present), this doesn't matter much]
    on top of state-holding objects which would otherwise not have these undo/redo ops
    (though they must have the ability to track changes and/or support scanning of their state).
       Assume that no other UndoManager or UndoArchive is tracking the same state-holding objects
    (i.e. we own them for undo-related purposes).
       #e future: Perhaps also delegate all command-method-calls to the state-holding objects...
    but for now, tolerate external code directly calling command methods on our state-holding objects,
    just receiving begin/end calls related to those commands and their subroutines or calling event-handlers,
    checkpoint calls from same, and undo/redo command callbacks.
    """
    pass

class AssyUndoManager(UndoManager):
    "An UndoManager specialized for handling the state held by an assy (an instance of class assembly)."
    def __init__(self, assy): # called from assy.__init__, i think
        # assy owns the state whose changes we'll be managing...
        # [semiobs cmt:] should it have same undo-interface as eg chunks do??
        ## self.thingies = {}
        self._current_main_menu_ops = {}
        self.archive = AssyUndoArchive(assy) # does initial checkpoint
        self.assy = assy #k still needed?
        assy._u_archive = self.archive ########@@@@@@@@ still safe in 060117 stub code??
            # this is how model objects in assy find something to report changes to (typically in their __init__ methods);
            # we do it here (not in caller) since its name and value are private to our API for model objects to report changes
        self.archive.subscribe_to_checkpoints( self.remake_UI_menuitems )
        self.remake_UI_menuitems() # so it runs for initial checkpoint and disables menu items, etc
        return

    def menu_cmd_checkpoint(self):
        self.archive.checkpoint( cptype = 'user_explicit' )

    def undo_checkpoint_before_command(self, cmdname = ""): #e should it be renamed begin_cmd_checkpoint()??
        auto_checkpointing = debug_pref('undo auto-checkpointing? (slow)', Choice_boolean_False) # recheck the pref every time
        if not auto_checkpointing:
            return
        # (everything before this point must be kept fast)
        cmdname = cmdname or "command"
        if undo_archive.debug_undo2:
            env.history.message("debug_undo2: begin_cmd_checkpoint for %r" % (cmdname,))
        # this will get fancier, use cmdname, worry about being fast when no diffs, merging ops, redundant calls in one cmd, etc:
        self.archive.checkpoint( cptype = 'begin_cmd' )
        return

    def undo_redo_ops(self):
        # copied code below [dup code is in undo_manager_older.py, not in cvs]
        ops = self.archive.find_undoredos() # state_version - now held inside UndoArchive.last_cp (might be wrong) ###@@@
        undos = []
        redos = []
        d1 = {'Undo':undos, 'Redo':redos}
        for op in ops:
            optype = op.optype()
            d1[optype].append(op) # sort ops by type
        return undos, redos
    
    def undo_cmds_menuspec(self, widget): # 060117; biggest chgs are name of doit/do_op, and state_version
        "return a menu_spec for undo-related commands (to be shown in the given widget, tho i don't know why the widget could matter)"
        del widget
        archive = self.archive
        # copied code below [dup code is in undo_manager_older.py, not in cvs]
        res = []
        res.append(( 'undo checkpoint (in RAM only)', self.menu_cmd_checkpoint ))

        undos, redos = self.undo_redo_ops()
        ###e sort each list by some sort of time order (maybe of most recent use of the op in either direction??), and limit lengths
        
        # there are at most one per chunk per undoable attr... so for this test, show them all, don't bother with submenus
        if not undos:
            res.append(( "Nothing we can Undo", noop, 'disabled' ))
                ###e should figure out whether "Can't Undo XXX" or "Nothing to Undo" is more correct
        for op in undos + redos:
            # for now, we're not even including them unless as far as we know we can do them, so no role for "Can't Undo" unless none
            arch = archive # it's on purpose that op itself has no ref to model, so we have to pass it [obs cmt?]
            cmd = lambda _guard1_ = None, _guard2_ = None, arch = arch: arch.do_op(op) #k guards needed? (does qt pass args to menu cmds?)
            ## text = "%s %s" % (op.type, op.what())
            text = op.menu_desc()
            res.append(( text , cmd ))
        if not redos:
            res.append(( "Nothing we can Redo", noop, 'disabled' ))
        return res

    def remake_UI_menuitems(self):
        undos, redos = self.undo_redo_ops()
        win = self.assy.w
        undo_mitem = win.editUndoAction
        redo_mitem = win.editRedoAction
        if platform.is_macintosh():
            # kluge; should do this sooner! but this might turn out to happen as soon as user can see it...
            win.editRedoAction.setAccel(win._MainWindow__tr("Ctrl+Shift+Z")) # was "Ctrl+Y"
        for ops, action, optype in [(undos, undo_mitem, 'Undo'), (redos, redo_mitem, 'Redo')]: #e or could grab op.optype()?
            if ops:
                action.setEnabled(True)
                assert len(ops) == 1 #e there will always be just one for now
                op = ops[0]
                action.setMenuText("%s to checkpoint" % optype)
                #e tooltip
                self._current_main_menu_ops[optype] = op #e should store it into menu item if we can, I suppose
            else:
                action.setEnabled(False)
                ## action.setText("Can't %s" % optype) # someday we might have to say "can't undo Cmdxxx" for certain cmds
                ## action.setMenuText("Nothing to %s" % optype)
                action.setMenuText("%s" % optype) # for 061117 commit, look like it used to look, for the time being
                #e tooltip
                self._current_main_menu_ops[optype] = None
            pass
        return
        ''' the kinds of things we can set on one of those actions include:
        self.setViewFitToWindowAction.setText(self.__tr("Fit to Window"))
        self.setViewFitToWindowAction.setMenuText(self.__tr("&Fit to Window"))
        self.setViewFitToWindowAction.setToolTip(self.__tr("Fit to Window (Ctrl+F)"))
        self.setViewFitToWindowAction.setAccel(self.__tr("Ctrl+F"))
        self.setViewRightAction.setStatusTip(self.__tr("Right View"))
        self.helpMouseControlsAction.setWhatsThis(self.__tr("Displays help for mouse controls"))
        '''
    # main menu items (their slots in MWsemantics forward to assy which forwards to here)
    def editUndo(self):
        env.history.message(orangemsg("Undo: (prototype implementation)")) #e or repeat the text from the menu item?
        self.do_main_menu_op('Undo')

    def editRedo(self):
        env.history.message(orangemsg("Redo: (prototype implementation)"))
        self.do_main_menu_op('Redo')

    def do_main_menu_op(self, optype):
        "optype should be Undo or Redo"
        op = self._current_main_menu_ops.get(optype)
        if op:
            self.archive.do_op(op)
        else:
            print "no op to %r; not sure how this slot was called, since it should have been disabled" % optype
        return
    
    pass # end of class AssyUndoManager

# == debugging code - invoke undo/redo from debug menu (only) in initial test implem

def undo_cmds_maker(widget):
    ###e maybe this belongs in assy module itself?? clue: it knows the name of assy.undo_manager; otoh, should work from various widgets
    "[widget is the widget in which the debug menu is being put up right now]"
    #e in theory we use that widget's undo-chain... but in real life this won't even happen inside the debug menu, so nevermind.
    # for now just always use the assy's undo-chain.
    # hmm, how do we find the assy? well, ok, i'll use the widget.
    try:
        assy = widget.win.assy
    except:
        import platform
        if platform.atom_debug:
            return [('atom_debug: no undo in this widget', noop, 'disabled')]
        return []
##    if 'kluge' and not hasattr(assy, 'undo_manager'):
##        assy.undo_manager = UndoManager(assy) #e needs review; might just be a devel kluge, or might be good if arg type is unciv
    mgr = assy.undo_manager #k should it be an attr like this, or a sep func?
    return mgr.undo_cmds_menuspec(widget)

register_debug_menu_command_maker( "undo_cmds", undo_cmds_maker)
    # fyi: this runs once when the first assy is being created, but undo_cmds_maker runs every time the debug menu is put up.

# end
