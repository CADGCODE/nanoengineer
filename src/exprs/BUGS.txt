cad/src/exprs/BUGS.txt

# $Id$

This is a place to record bugs in the exprs module that need to not be
forgotten, and have no better place to be recorded at this time (the use of
bugzilla being premature at this early stage of its development).

Most bugs are apparent enough that the best place to discuss how to fix them
is next to the code that will have to be fixed, in a comment or in a
"printnim" call.

But for a few, it's hard to know where to record them, or they might be
forgotten there, so they're listed here, in order of addition to this file.

When they get fully fixed, and after a few days are thought to be
permanently fixed, they can be moved from this file into BUGS-fixed.
If they are just worked around but need better fixes later, they should
remain in this file (if code comments are not enough).

See also:
- the list of planned optimizations (optims) in test.py
- anything marked ###BUG in the source files
- the "list of language deficiencies or todos" in PLAN

===

061208 texture dims not always a power of 2 (from a couple weeks ago)

I rely on OpenGL handling textures of arbitrary
sizes, even though some OpenGL drivers or chips require their dimensions to be
powers of 2. Before release, we should add code to ask OpenGL whether it can handle this,
and work around it if not.

==

061208 Fix the jig select code in modes files as described here:

    # self.current_glselect - FIX UNLESS LOCAL - seems ok since local -- WRONG, external code looks at it! (modes, selectMode)
        # btw, the same code in those files fails to set it here... in fact maybe i'm wrong and it doesn't look at it,
        # but starting now [061208 1032p] Highlightable is going to look at it, so (1) i'll put it in self.delegate,
        # (2) the jig select code in those files might be wrong now, if I ever draw jigs in funny projection matrices
        # (as I surely will someday).

==

[maybe NAB] 061210 usage-tracking of glpane attrs width, height, zoomFactor, scale

Calls to gluProject, gluUnProject (eg via mousepoints) get results which depend on those variables, but don't usage-track them.
We can ignore this in terms of knowing about global redraw (since changes to those would trigger it), but not
for knowing when to invalidate display lists. OTOH, maybe those funcs can't be run inside them? I'm not sure.

More generally, I'm not sure whether we need usage-tracking of glpane height & width for related things like DrawInCorner.

==

061211 testmode model viewpoint seems wrong

how come testmode shows the model (with atoms, in assy) in a different viewpoint than
Build mode does?

I suspect it translates before drawing it. But I can't find any code that would do that!

update 061218: I recently (a few days ago?) saw some glTranslates in testdraw that might do that,
and added prefs to not run that code (or other related code), and checkboxes in lower left
corner to control those, so maybe this fixed it (when those checkboxes are off), but I
didn't test that yet. ... Now I did; it's not fixed. 

But I have another theory: it might just be due to the larger glpane in testmode as opposed
to Build mode, due to fewer toolbars being visible when in testmode. ####k should test that,
perhaps by making a debug pref for whether or not to remove the toolbars in testmode.

==

061218 when highlighting the fake openclose icons in e.g. testexpr_10c,
only the gray rect is seen, not the + or - text. I first noticed this just after fixing the
previous bug, so that fix may have caused it, but I don't often try to highlight those icons,
so that fix having caused it is not proven.

(Speculation: this might be an effect of the roundoff issue mentioned at the end of that bug
discussion, above.)

update 061219: more likely, it's just that Overlay scan order is backwards, 
appropriate for GL_LESS but not for GL_LEQUAL, and the buggy fake icon makes use of an Overlay
of gray rect and text. Fixable by reversing Overlay order in this case, or switching
to GL_LEQUAL all the time (or all the time in testmode, provided these things are not
drawn in other modes, but since model objs are drawn there, that makes no sense except
as a temporary situation). 

update 070105: Here is a specific better way of doing the above fix:

plan: new glpane var, set up in init_glpane_vars, default_glDepthFunc,
normally one thing for NE1 and same for me, but have debug pref to make it normally the other;
and then change it in highlightable
to optim the nonuse of gldepthfunc
so when pref is set i never call it except when entering and leaving mode

also let this glpane var determine overlay order
(even tho it's only the default not the current)

then i predict my openicon hlighlight bug (that hides the plus sign) goes away and no other bugs come

no need yet to avoid descend into displists in highlighting, which in any case i don't want to do --
rather when HL has those decorators on draw, they should avoid displists only if some elements of them
should not be descended into -- once they reach level of draw it all, they should use them
(a dynamic flag seen by decorator will no longer say "be careful what you draw").

==

070106 when you draw one instance twice, Highlightables only work within the last-drawn copy,
since Highlightable only stores one draw-coord and draws one highlight-image.

It would not be too hard to make it store a series and redraw them all. But it might be better
to make these two instances get an env with different "highlighting state" -- except then they're
not really the same instance, are they? (Since .env is a function of instance.)

Either way, then we could implement stereo this way!

(My guess is, one instance recording >1 highlight pos is more efficient, as well as simpler,
than making two instances which share some stateplaces and not others. It's done for every
highlightable in the model, so you don't want the increased RAM to be larger than necessary.)

(The syntax for drawing one instance twice is also klugy and may stop working -- see testexpr_26
and its comments. But that's not this bug.)

==

070109 highlight update bug: in code like this (from demo_drag.py), 
the highlighted form doesn't get updated soon enough after it changes when the button is pressed,
as mentioned in the comment at the end:

If_kluge( getattr_Expr( world, '_cmd_Clear_nontrivial'),
          ActionButton( world._cmd_Clear, "button: clear"),
          ActionButton( world._cmd_Clear, "button (disabled): clear", enabled = False)
 ) 
 # works, though text change is so slow I suspect there's actually a highlighting or update bug 
 # making it appear even slower...
 # update 070109: the bug seems to be that as long as the mouse stays on the button, 
 # it remains highlighted with the old highlight form.

Theory: an old instance is stored in selobj/stencilbuffer and is being redrawn in abs coords,
and seems still selected even though a new instance has replaced it. But (1) I didn't confirm
it's a different instance, (2) even if it is, I'm not sure why already-coded checks are not
enough... but maybe the idea of an object not drawn in a frame becoming invalid as selobj
is still nim?? Not sure, but I bet it is, since I can't recall any record of whether an obj
does get drawn in a frame or not. (Just set a "last drawn in this frame" ivar in draw...) ####k

==

[worked around in demo_drag.py:]

070115 "highlightable-finder can be fooled due to _check_target_depth_fudge_factor of 0.0001"

[in earlier commits today, I misnamed this bug based on an incorrect theory of its cause:
070115 "DisplistChunk breaks highlighting of testexpr_19f old nodes"]

[I'll remove these debugging notes sometime after this commit, and leave only the correct parts:]

in testexpr_19f:

drag of old nodes seems broken. is this is new or old bug?
I dimly remember hacking on the related code in demo_drag...
am I using _19f which is revised somehow? yes but it's old -- the improved clear button.

bug also appears in $B (doesn't have my lmods "revised stub types & type coercion, canon_type")

trying again carefully in $W, I note:

- disabling the debug pref for glpane skipping of Qt-redraws does not fix it; 
  further tests done while leaving it disabled (more redraws than usual for me, normal for NE1)
  (so this debug pref being False might be partially fixing this bug in the following tests,
   for all i know)

- the mouse over the little black rect reports same sbar msg (no change in sbar as I mouseover --
  indicating a bug in highlighting the rect) but does a new redraw per mousemotion
  (as if it's drawn in front but not drawn with a glname)

- tilt in XZ -- now old node is shown tilted (and draggable? not sure)
  but now I can't even make a new node (due to highlight/displist bug?)

- remake main instance, now i can make a new node, and can drag an old node

  (so I wonder if this is caused by the highlighting bug related to DisplistChunk -- try disabling all those ###)
  
  and the old node is no longer tilted -- i think that indicates some sort of displist update bug!
  either that, or it's a bug in the drawing code that it implicitly uses the to-screen direction...
  or maybe it's related to snapshotting the look-expr for the node when making it... not sure ###

trying disabling displists: fixes all reported bugsI tried (all 3 rects are draggable
and affect sbar on mouseover, some just made and some from before remake main instance,
both before and after untilting using "home view")

conclusion: guess: bug is either in displist updating, or interaction of displist and highlight.
I'll add comments to DisplistChunk and Highlightable mentioning this bug.

WRONG -- not so simple: trying it more, even with that debug_pref disabled, it is intermittent --
it might depend on how long I leave the mouse down when I make the node, or whether I move it over
the node at that time, or on which files were modified and presumably got reloaded w/o main instance
being remade (since this was changing over time as I did a commit).

Trying it again in a fresh session, I get an exception:
UnboundLocalError: local variable 'node_expr' referenced before assignment
  [selectMode.py:2294] [Highlightable.py:552] [Highlightable.py:649] [demo_drag.py:513]

I was wondering about that bug just before since I glanced it in the code,
but then couldn't see it when I read it more carefully 
(node_expr assignment is in else of 'if not self.use_VertexView', so doesn't happen;
 use is in else of 'if 0', so does happen). No idea why it was working before.
Not sure if it can relate to this bug, anyway. 

Fix that, try again in fresh session:

I still get the bug, and this time, no big chance DisplistChunk or file reload could be involved.
WAIT, my debug_pref to disable DisplistChunk is not persistent! So maybe it's still causing this.
Turning it off & remaking instance, bug can still happen on new nodes. I'll need to make that debug_pref
persistent and test again more carefully. ### TRY THAT LATER [I did]

... now I think the bug is caused by the 0.0001 being too large in check_target_depth in GLPane
compared to the DZ * PIXELS * 1 or 2 in different places in demo_drag.py.
Replacing them all with PIXELS * 3... this seems to have fixed it, even if I change all
debug_prefs back to defaults (enable displists, skip redraws only wanted by Qt).
But if I zoom out a bit, bug is predicted back... can't test that with displists enabled... 
not tested this time.

A better fix would be to change the 0.0001 in check_target_depth (see code comments for problems
to solve first); for now I made it depend on mode, but made testmode set it to existing value.
And the DZ * DZFUZZ (3 * PIXELS) in demo_drag.py could be replaced by a depth offset which
doesn't depend on zoom history (i.e. not a value in model coords like now). Note that for use
in displists, this has to be a real depth offset, not a computed model coord change.

WARNING: It's possible that the value of DZFUZZ needed to work around this bug depends
on the GLPane size, or on user prefs settings, or on Ortho vs Perspective! (all speculations)

==

